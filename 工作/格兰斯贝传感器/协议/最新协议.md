# 格兰斯贝存在传感器串口协议

* 升级包、飞升方式、调试过程中有任何问题给个包
  * 比如串口上的数据不是想要，有什么改动需要进行调整
  * 传一个升级包过来升级
* 电源5V
* OP蓝牙模组，2.4G存在传感器，恒照度传感器、复位开关
* 存在传感器OP蓝牙模组里面有，2.4G存在传感器里面也有，有一个综合判断的结果，通过串口发到OP模块上去
* 恒照度相对来说比较简单，主要是一些调光的算法然后会做一些处理，处理之后会变成一些照度值或者说是调光的值然后通过串口给到OP模块
* OP的模块有I2C还有串口，串口用来做调试用，背后放了三个焊盘，可以对OP模块进行调试
* OP模块烧程序就在3个过孔，2.50的过孔做程序的烧录
* 两个模块之间要用的是2个串口线，**串口线要调试用要跟我们通信，不知道配置的时候会不会有问题，到时候如果说有问题的话到时候在想怎么去配置**，为了解决这个问题烧录一个可以随意飞升的包，把这个包烧录进去之后，在使用过程中如果有一些通讯上的问题或者需求变更的话会给一个升级包用APP去找设备然后对它进行升级，这里面的固件就会更新掉方便调试，防止这条路也走不通把OP的I2C也引出来了和我们的模组先连起来了，只是目前空间有限，没有预留上拉的电阻，如果真的各方面资源协调确实协调不开，需要用I2C进行通讯的话，我们这边进行5500欧姆的电阻上拉试试看能不能保证芯片正常的通信，人体硬件是这么个思路
* 这边是5V的一个供电，能到300mA的样子，会变成3.3V，这个3.3V同时给我们供电，同时给你们供电，之间是完全通的，没有任何隔离限制，但是电源和2.4G存在传感器是有隔离限制的，相信电流应该也是够用的，应该没什么问题，测过你们的程序，反正整体的耗电是相对比较低的大概7、80mA的样子，这个硬件讲完了之后
* 讲一下，这两个模组之间的通信，约定一些功能，上个版本发的程序太复杂，而且都是和灯控相关的，灯控是一套独立的，灯控是你们自己的蓝牙会控，所以对协议进行了极大的简化，尽量把时间省下来
* 文档过一下，基本设置115200，同步头55AA，注意一点这是一个大端模式，**看一下你们那边是大端模式还是小端模式，很多时候串口通不了就是因为大小端模式不对造成的，**
* 数据格式约定了一些数据的格式，这个数据格式正常情况下选00就可以了，用这种透传的方式就可以，根据之前开会讨论的内容定义了几个命令字，一个是心跳检测、一个是存在传感器的复位、一个配对，其实配对的话，严格意义上来讲，我们的产品是不需要配对的，然后这个配对是我们这次特意加上的，因为OP是需要配对的，欧普的配对，和我们的这个没有关系，只是为了保持一致加上去了，开发不要有误解，我们的产品是不需要配对的，两个之间是有线连接的，没有配对的情况
* 命令发送，**命令发送相当于是OP的模组发给格兰斯贝的模组**，状态上报相当于反过来，格兰斯贝传感器的模组发消息给OP的模组
* 状态的查询就是命令发送的特殊情况，可以进行状态的查询
* 心跳检测，心跳检测主要就是你们这边来看，我们这边有没有挂掉，正常情况下，这边因为有硬件的看门狗，然后还有一个就是做了一个软的监控来确保不会出现这种挂了的情况，做72小时完全没有问题，但是根据之前的经验，当纹波或者其他情况造成一些或者供电短时间不足的情况下，可能会产生复位，但是复位时间非常快，就把心跳检测开放出来，看我们的模组是否是活着的
* 这一块相对来说比较重要的一点，会把有人无人的消息给到你们，传统情况下，感应到有人就会发一条消息，发一个高电平或者串口端就发一条消息，这个消息在原来的逻辑是一直发的，只要有人就一直发，3s发一次3s发一次，默认3s当然可以可以设为1s最短时间是1s，最长可以一次9s、12s、50s都是没问题的，这个词是双方还没有约定好，**所谓的约定好就是从开始感受到有人，或者感应到没人我需要在多短的时间内，给到你们**因为本身存在传感器内部算法的时间跨度其实是蛮长的，等到最终积分算完之后，再到时间延时，再到执行器件，我们产品测下来应该是在几百个ms内，所以说最小时间设的是1s，就相当于我能进到这个场景里面去了之后，大概在不到1s的时间，就能够把最终的结论算出来，把这个时间给到你们，如果说这个时间想继续在缩短，因为现在是1s想继续在缩短，看后续使用的情况，也是有一些手段能够把时间缩短，但这个缩短，我们测下来对训练也没有特别大的影响只是这套体系沿用以前原来所有的传感器，1s1s3s3s这种体系过来，我们原来5.8G是1s再早之前高频的是3s，所以就把这套体系沿用下来了，我理解你们这块可能会有需求，我提前就先讲一下，你们到时候写到这部分代码或者测试到这部分的时候，看你们的感受
* 存在传感器复位，正常情况下这个复位按键同时给了你们的模组、也给了我们的模组，这个在实测的时候，要看一下电平上会不会有影响，因为我这边比如说配成了高阻，然后你们这边配成推挽也好高阻也好其实是会有影响的，这个复位电路是两个模组并联的用，最终量产的时候肯定只选一边来接收消息，如果你们来接收可以告诉我，如果是我们来用你们告诉我就好了，复位的消息是格兰斯贝的模组给到OP的模组还是你们自己去做判断其实都是可行的，硬件上全保留下来了
* 然后配对模式，我们当前的配对模式是和产品定义上写的是一样的，断电上电，断电上电多少次来进行配对也好，组网也好，这个功能更多的时候是直接给到OP模组去用，因为你们是有一个配对模式的，这种情况下为什么格兰斯贝的模组也写了一个配对模式呢？就是专门针对一种情况，就是客户忘了设备的密码，我们的模组是随身密码的，OP去卖，当前的密码体要不要去导入，主要用途就是可能我们家的邻居，绝对我们家东西很好，买一套和我们一摸一样的，在我们的这种产品下是需要加一个密码来做区隔的，因为加了密码之后从物理上就完全看不出有任何的数据了，不像软加密，软加密的话像这样的产品还是可以看到只不过我错过他配网状态，我可能就没办法配网，但是这个信息本身我是能够看得到的，只要在某种情况下还是能够看到邻居的这些数据的，然后在我们体系中是只要密码连上去邻居是完全看不到的，我们这个产品要不要导入密码体系，如果要导入的话未来可能会带来一些问题，如果客户密码忘了，总不能让他返厂，所以这个配对有2个作用，一个是给咱们的模组进行配网用，另一个格兰斯贝的模组进入配置模式的话，OP把控制权掌握完了，这种情况下，格兰斯贝在这个操作时间内，最长不超过3min配置上面会自动把这个关掉，在这个时间内，他的密码是无效的，你就可以对他做任何的操作，可以把屏幕密码复位什么的都是可行的，这个配对有两个作用
* **检测状态上报、无人状态上报这部分就比较简单，这个到时候实测一下看需要怎么调整，就是有人了给你们消息，不停的发，有人无人的消息发几次也可以去定义，因为发一次之后，虽然是有线连接的但是怕万一就是丢掉了，之后会比较麻烦，我们会连续发，发多少次，我们自己产品体系的话发三次默认是发3次，有人无人消息发三次，这个体系带来的效果是什么样，就是你们成功收到消息之后，看你们的逻辑怎么去处理它，通过我们的协议你能够知道他是新发的一条的，第一次还是上一条消息重发的第二、第三次通过协议里面你们是看的到的，你们把去重处理掉就好**
* 参数设置，06指令里面还会有一些子参数，在我们产品体系中命令发送里面的关键字其实是可以自己定的，可以约定好01设什么，02设什么...