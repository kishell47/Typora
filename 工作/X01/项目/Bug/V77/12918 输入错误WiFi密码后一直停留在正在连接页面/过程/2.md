  * ~~~C++
    ConnectionAssistant assistant_;	//assistant_是ConnectionAssistant类对象


    /**
     * @brief Wifi信息监听接口
     */
    class IWifiListener {
    public:
        virtual ~IWifiListener() { }
        virtual void handleWifiEnable(E_WIFI_ENABLE event, int args) { }
      virtual void handleWifiConnect(E_WIFI_CONNECT event, int args) { }
      virtual void handleWifiErrorCode(E_WIFI_ERROR_CODE code) { }
      virtual void handleWifiScanResult(std::vector<WifiInfo>* wifiInfos) { }
      virtual void notifySupplicantStateChange(int networkid,
              const char* ssid, const char* bssid,
              E_SUPPLICATION_STATE newState) { }
  };

  class ConnectionAssistant: public WifiManager::IWifiListener{	//ConnectionAssistant是IWifiListener的派生类,公开继承IWifiListener类中的公共成员

  public:
      typedef boost::function<void(const std::string& msg)> ConnectionProgress;
      //ConnectionProgress是一个函数指针类型
      
      bool Connect(const std::string& name,
        const std::string& password, ConnectionProgress progress) {
      WifiManager* w = NETMANAGER->getWifiManager();
      if (w->isConnected()) {
        w->disconnect();
      }
      usleep(1000 * 1000);
      progress_ = progress;
      w->addWifiListener(this);
      w->connect(name, password);
      Wait();
      w->removeWifiListener(this);
      return w->isConnected();
    }
  };
  ~~~
  
  * `typedef boost::function<void(const std::string& msg)> ConnectionProgress;`
  
    * 这行代码定义了一个名为`ConnectionProgress`的类型，它是一个<font color='red'>**函数对象类型**</font>，接受一个`std::string`类型的参数并返回`void`。
  
      * <font color='red'>**函数对象类型**</font>[点击跳转到函数对象类型](#函数对象类型)<a id = "返回正文31"></a>
  
    * 具体来说，它是由<font color='red'>**`boost::function`模板类**</font>定义的，它将函数对象包装在一个可调用对象中，可以像函数指针一样使用，并且支持函数指针、成员函数指针、函数对象等多种可调用对象的语义。
  
      * `boost::function`是一个<font color='red'>**函数对象包装器**</font>，它允许将任意可调用对象（如<font color='red'>**函数指针**</font>、<font color='red'>**成员函数指针**</font>、函数对象）存储在一个对象中，并像函数一样调用它们。
        * <font color='red'>**函数对象包装器**</font>[点击跳转到函数对象包装器](#函数对象包装器)<a id = "返回正文32"></a>
        * <font color='red'>**函数指针**</font>[点击跳转到函数指针](#函数指针)<a id = "返回正文30"></a>
        * <font color='red'>**成员函数指针**</font>[点击跳转到成员函数指针](#成员函数指针)<a id = "返回正文33"></a>
      * 其定义如下：
  
      ```C++
      template<class R, class... Args>
      class function<R(Args...)>;
      ```
  
      * 其中，`R`表示函数返回值类型，`Args`表示函数参数类型。
      * 该模板类支持多种构造函数和赋值操作符，可以方便地实现函数对象的存储和调用。
      * 同时，它还支持类型擦除，可以将不同类型的可调用对象都封装在同一个对象中。
      * 这种灵活性使得它成为一个重要的工具，广泛应用于C++的函数式编程和<font color='red'>**回调机制**</font>中。
        * <font color='red'>**回调机制**</font>[点击跳转到回调机制](#回调机制)<a id = "返回正文34"></a>
  
  * `WifiManager`：`Wifi管理器类`
      /**
      
       \* @brief Wifi管理器
      
       */
      
      class WifiManager {
  ~~~

  * `IWifiListener`：`Wifi信息监听接口`
  
    * ~~~C++
      	/**
      	 * @brief Wifi信息监听接口
      	 */
      	class IWifiListener {
      ~~~

* `typedef boost::function<void(const std::string& msg)> ConnectionProgress;`
  * 这行代码定义了一个名为`ConnectionProgress`的类型别名（typedef）
  * 它是一个<font color='red'>**函数类型**</font>，该函数接受一个字符串参数`msg`，返回值为`void`。
    * <font color='red'>**函数类型**</font>[点击跳转到函数类型](#函数类型)<a id = "返回正文14"></a>
  * <font color='red'>**函数类型是一个函数指针类型的语法糖**</font>，它允许我们声明一个类型，这个类型可以作为函数的参数或返回值类型。
    * <font color='red'>**函数类型是一个函数指针类型的语法糖**</font>[点击跳转到函数类型是一个函数指针类型的语法糖](#函数类型是一个函数指针类型的语法糖)<a id = "返回正文15"></a>
  * 该函数类型是通过`boost::function`库来定义的，它提供了一种将函数作为对象来处理的方法，使得函数的行为可以像对象一样进行传递、复制和存储。
  * 在这里，`boost::function`库被用来定义一个可以接受字符串参数的<font color='red'>**回调函数类型**</font>。
    * <font color='red'>**回调函数类型**</font>[点击跳转到回调函数类型](#回调函数类型)<a id = "返回正文24"></a>
  * 因此，当我们使用`ConnectionProgress`类型别名时，实际上是在声明一个<font color='red'>**函数指针类型**</font>的变量，这个变量可以接受一个参数为字符串类型的函数指针，用于表示一个处理连接进程的回调函数。



# <font color='red'>**回调机制**</font>

* <a href="#返回正文34">点击返回正文</a>
* **回调机制**是一种常见的编程模式，它允许**将一个函数作为参数传递给另一个函数，并在需要时调用该函数。**通常情况下，回调函数是在<font color='red'>**异步事件**</font>发生时调用的，例如网络通信、GUI操作等。
  * <font color='red'>**异步事件**</font>[点击跳转到异步事件](#异步事件)<a id = "返回正文35"></a>
* 在**回调机制**中，通常有两个角色：**调用方**和**回调方**。
  * **调用方**定义一个函数，接受一个函数指针或函数对象作为参数，并在需要时调用该函数。
  * **回调方**实现一个函数，该函数符合调用方指定的函数签名，并在需要时由调用方调用。
* 回调机制有很多应用场景，例如：
  - 网络通信：当网络收到数据时，调用方需要调用回调函数进行处理。
  - GUI编程：当用户触发某个事件时，调用方需要调用回调函数进行相应的处理。
  - 多线程编程：当一个线程完成任务后，调用方需要调用回调函数通知主线程或其他线程。
* 在C++中，回调机制可以使用函数指针、函数对象、std::function等方式实现。使用函数对象或std::function可以更灵活地实现回调机制，因为它们可以保存状态和数据，并在需要时重复使用。



# <font color='red'>**异步事件**</font>

* <a href="#返回正文35">点击返回正文</a>

* **异步事件**通常是指在程序中发生的一些<font color='red'>**非阻塞的事件**</font>，例如网络连接请求、文件读写请求、计算任务等等。这些事件通常需要花费一定的时间才能完成，并且在等待的过程中程序不能停止响应其他请求。因此，我们需要使用异步事件处理机制来保证程序的高效和响应能力。

  * <font color='red'>**非阻塞的事件**</font>通常是指程序在处理一个事件时，不会停止并等待事件的完成，而是通过一些方法（例如使用<font color='red'>**多线程**</font>、<font color='red'>**异步回调**</font>等）继续执行程序的其他部分。当事件完成时，程序会收到一个通知，然后再进行相应的处理。

    * <font color='red'>**多线程**</font>是指在一个程序中同时执行多个线程（或称为子任务），每个线程都是独立的执行路径，它们可以并行地执行，从而提高程序的运行效率。
      * **程序和线程的区别**
        * **程序**是指一组指令序列和相关数据的集合，它是**静态的**，只有在执行时才会动态地改变其状态和结果。
        * 多线程是指在同一个程序中同时执行多个线程的机制。
          * 每个线程可以独立地执行一段代码，有自己的程序计数器、栈、寄存器等资源。
          * 多线程的实现可以充分利用多核处理器的优势，提高程序的<font color='red'>**并发性**</font>和执行效率。
            * 并发性指的是在同一时间内有多个独立的任务在执行。
            * 在计算机领域中，通常指多个<font color='red'>**线程**</font>或<font color='red'>**进程**</font>在同时执行。
            * 并发性可以充分利用<font color='red'>**多核处理器**</font>等硬件资源，提高系统的响应速度和<font color='red'>**吞吐量**</font>。但同时也需要考虑<font color='red'>**线程安全和同步**</font>等问题，确保<font color='red'>**多个线程或进程**</font>之间的数据访问和操作正确无误。
        * 因此，程序和多线程的区别在于，程序是一个静态的代码集合，而多线程是一个动态的执行机制，可以在程序运行时实现并发执行。
          * 线程是指程序中一个独立的执行路径。
          * 在多线程程序中，一个进程可以同时运行多个线程，每个线程独立运行，具有自己的栈和局部变量，但共享进程的全局变量和堆内存。线程是操作系统进行调度的最小单位，它可以利用多核处理器的性能优势，提高程序的执行效率和并发性能。在编写多线程程序时，需要注意线程同步、互斥和竞态条件等问题，以保证程序的正确性和稳定性。
    * **多线程**常用于需要同时处理多个任务的应用程序，例如<font color='red'>**图形界面应用程序**</font>、<font color='red'>**服务器程序**</font>等。
      * **图形界面应用程序**是指使用图形化用户界面（GUI）的应用程序，用户可以通过鼠标、键盘或触摸屏等交互设备来与应用程序进行交互。
      * 相比于命令行界面（CLI）应用程序，图形界面应用程序通常更加直观和易于使用。
      * 常见的图形界面应用程序包括文本编辑器、图像处理软件、音乐播放器、浏览器等。
      * 在开发图形界面应用程序时，通常需要使用专门的图形界面开发框架或库，例如Qt、GTK、wxWidgets等。

    * **服务器程序**通常是指在网络上运行并提供一定服务的计算机程序。服务器程序需要处理来自客户端的请求，并返回相应的响应。
      * 服务器程序通常在后台运行，可以为多个客户端提供服务。
      * 常见的服务器程序包括Web服务器、邮件服务器、数据库服务器等。

    * **图形界面应用程序**通常需要使用多线程来避免阻塞<font color='red'>**主线程**</font>，因为用户交互事件必须在主线程中处理。
      * **主线程（main thread）**是指一个程序中第一个被操作系统调度执行的线程，也是整个程序中的主要线程，通常用来执行一些初始化操作，以及启动其他线程。
        * 在单线程程序中，主线程是唯一的线程。在多线程程序中，主线程通常会启动其他的线程，然后等待其他线程执行完毕，最后再进行一些清理工作。主线程和其他线程一样，也有自己的线程栈和线程控制块，操作系统会负责主线程的调度和资源管理。
      * 例如，如果在主线程中执行一个耗时的计算任务，那么用户界面将无法响应，这将导致应用程序看起来已经崩溃了。为了避免这种情况，可以将计算任务放在一个单独的线程中运行，以便主线程可以继续响应用户交互事件。
    * 另外，图形界面应用程序中通常会有很多<font color='red'>**并发**</font>的任务需要执行，例如<font color='red'>**网络请求**</font>、<font color='red'>**数据加载**</font>、<font color='red'>**文件IO**</font>等。
    * 使用多线程可以充分利用计算机的<font color='red'>**多核处理能力**</font>，提高应用程序的性能和响应速度。
    * 同时，多线程也能够使得代码更加清晰和易于维护，因为每个任务可以被封装在单独的线程中，而不必将它们混杂在一起。
    * 服务器程序
    * 在多线程中，需要考虑线程之间的同步和互斥问题，以保证程序的正确性和稳定性。

  * 这种方式的好处是可以提高程序的响应性能，避免程序因为等待事件完成而被阻塞，从而影响程序的整体性能。同时，非阻塞的事件处理方式也可以更好地适应不同的应用场景，例如<font color='red'>**网络编程**</font>、<font color='red'>**多线程编程**</font>等。

  * 举个例子，假设我们需要从一个文件中读取数据并进行处理。如果我们使用阻塞式的文件读取方式，程序会在读取文件时被阻塞，直到文件读取完成后才能继续执行程序的其他部分。但是如果我们使用非阻塞式的文件读取方式，程序可以在读取文件的同时继续执行其他部分，当文件读取完成后，程序再根据需要进行相应的处理。这种方式可以避免程序因为等待文件读取而被阻塞，从而提高程序的响应性能。

* 异步事件处理机制通常采用回调函数的方式来实现。当一个异步事件发生时，程序会立即返回，并启动一个<font color='red'>**新的线程或任务**</font>来处理这个事件。处理完成后，会<font color='red'>**调用预先注册的回调函数**</font>来通知程序事件已经完成，并返回处理结果。这种机制可以确保程序在等待事件完成的同时能够继续响应其他请求，从而提高程序的并发能力和响应能力。

* 在C++中，异步事件处理通常使用异步回调函数或future/promise对象来实现。

  * 异步回调函数是一个函数指针或函数对象，当异步事件完成时会自动调用该函数并传递相应的参数。
  * future/promise对象则是一种用于在线程间传递数据的机制，future对象表示一个异步任务的结果，而promise对象则用于设置该结果。当异步任务完成时，程序可以通过调用future对象的get()函数来获取结果，而在异步任务中，程序可以通过promise对象来设置结果。
  * 例如，我们可以使用异步事件处理机制来实现一个网络下载器，当用户发起一个下载请求时，程序会立即返回，并在后台启动一个新的线程或任务来下载文件。
  * 下载完成后，程序会自动调用预先注册的回调函数来通知用户，并返回下载结果。
  * 这样可以确保程序在等待文件下载完成的同时能够继续响应其他请求，从而提高程序的并发能力和响应能力。



















# <font color='red'>**成员函数指针**</font>

* <a href="#返回正文33">点击返回正文</a>

* 成员函数指针是指向类成员函数的指针。类成员函数必须与一个对象实例关联，因此成员函数指针除了指向函数外，还需要知道该函数所属的对象。
* 成员函数指针的语法与普通函数指针略有不同。
  * 对于类 `Foo` 中的成员函数 `bar`，其指针类型可以用 `void (Foo::*)()` 表示。
  * 在使用成员函数指针时，需要使用成员选择运算符 `.*` 或 `->*`，将对象实例与函数指针绑定起来。
  * 例如，`myFoo.*barPtr()` 表示将 `myFoo` 对象实例与指向 `Foo` 类中的 `bar` 成员函数的指针 `barPtr` 绑定起来并调用。
* 注意，成员函数指针只能指向非静态成员函数，因为静态成员函数没有隐式的对象实例参数。



# <font color='red'>**函数对象包装器**</font>

* <a href="#返回正文32">点击返回正文</a>

* **函数对象包装器**是一种可以将任何可调用对象（包括函数指针、函数对象、成员函数指针等）转换为**函数对象类型**的工具。

* 在C++中，常用的函数对象包装器有`std::function`和`boost::function`等。

* **函数对象包装器的作用是将函数和函数的参数绑定到一起，形成一个可以被调用的对象**，以达到更加灵活的编程目的。

* 例如，在编写事件处理程序时，我们可以使用函数对象包装器将事件处理函数和相关的数据（如事件类型、处理器对象等）绑定在一起，从而更加方便地处理事件。

* 下面是一个使用`std::function`的例子，将一个函数对象和一个参数绑定在一起，形成一个可以被调用的对象：

  ```c++
  #include <iostream>
  #include <functional>
  
  int add(int a, int b) {
      return a + b;
  }
  
  int main() {
      std::function<int(int)> func = std::bind(add, std::placeholders::_1, 2);
      int result = func(3);
      std::cout << "result = " << result << std::endl;
      return 0;
  }
  ```

  * 在上面的代码中，`std::bind`函数可以将函数`add`和一个常量值2绑定在一起，形成一个只有一个参数的函数对象`func`。然后，我们将参数3传递给函数对象`func`，执行加法操作并返回结果。最终输出结果为`result = 5`。

  * `std::placeholders::_1` 是 C++ 标准库 `<functional>` 中定义的一个<font color='red'>**函数参数占位符**</font>，它可以用作函数对象的形参，表示在函数调用时由实参提供。

    * <font color='red'>**函数参数占位符**</font>[点击跳转到函数参数占位符](#函数参数占位符)<a id = "返回正文34"></a>
    * 在使用时，需要使用 `std::bind` 或者类似的函数将参数绑定到占位符上，以便在调用时使用
    * 举个例子，假设有一个函数 `void foo(int a, int b)`，我们想要通过 `std::function` 封装它，并将其中一个参数 `a` 绑定为 42，可以这样写：

    ```c++
    #include <functional>
    
    void foo(int a, int b) {
      // ...
    }
    
    int main() {
      std::function<void(int)> f = std::bind(&foo, 42, std::placeholders::_1);
      // 调用 f(1) 相当于调用 foo(42, 1)
      f(1);
      return 0;
    }
    ```

    * 在上面的代码中，`std::placeholders::_1` 表示在调用 `f` 时，由实参提供的第一个参数。
    * 在 `std::bind(&foo, 42, std::placeholders::_1)` 中，将参数 `a` 绑定为 42，而将参数 `b` 绑定为占位符 `_1`，以便在调用 `f` 时使用。



# <font color='red'>**函数参数占位符**</font>

* <a href="#返回正文34">点击返回正文</a>

* **函数参数占位符**是一种特殊的标识符，用于在定义**函数模板**或者**lambda表达式**时表示一个**占位符参数**。

  * 在C++11中引入了一个新的标准库头文件`<functional>`，它包含了一些占位符参数，例如`std::placeholders::_1`、`std::placeholders::_2`等等。
  * 这些占位符参数可以用于定义函数模板和lambda表达式的参数列表，它们表示一个未知的参数类型，并且在函数调用时需要进行替换。
  * 例如，如果定义了一个函数模板，其中有一个参数类型是未知的，可以使用占位符参数来表示这个未知的参数类型。示例如下：

  ```c++
  template<typename T>
  void foo(T arg1, std::function<void(T)> callback) {
      callback(arg1);
  }
  ```

  * 在上述示例中，`std::function<void(T)>`表示一个函数对象类型，它需要一个参数类型为`T`的参数。
  * `foo`函数中的第二个参数`callback`就是这个函数对象类型的<font color='red'>**实例**</font>。在调用`callback`时，需要传递一个`T`类型的参数。这个参数可以通过占位符参数来传递。
  * 例如，可以使用`std::placeholders::_1`表示这个未知的参数类型，示例如下：

  ```C++
  foo(42, [](int x) { std::cout << x << std::endl; });
  ```

  * 在上述示例中，`foo`函数的第一个参数是一个整数类型，它的值是`42`。
  * 第二个参数是一个lambda表达式，它需要一个`int`类型的参数。
  * 在lambda表达式中，使用了`std::placeholders::_1`来表示这个未知的参数类型。
  * 在调用lambda表达式时，会将`42`作为这个未知的参数类型进行替换，并输出`42`。





# <font color='red'>**函数对象类型**</font>

* <a href="#返回正文31">点击返回正文</a>

* **函数对象类型**指的是一个类，其中包含了一个或多个重载的 `operator()` 函数，可以被当作函数使用。这种类型的对象可以像函数一样被调用，同时还可以包含状态和数据。在 C++ 中，函数对象可以通过定义一个类，并在其中定义一个 `operator()` 函数来创建。例如：

  ```c++
  class MyFunctionObject {
  public:
      int operator()(int x, int y) const {
          return x + y;
      }
  };
  
  int main() {
      MyFunctionObject myFunc;
      int result = myFunc(3, 4); // result is 7
      return 0;
  }
  ```

  * 在这个例子中，`MyFunctionObject` 是一个函数对象类型的类，其中的 `operator()` 函数可以将两个整数相加。
  * 在 `main()` 函数中，我们创建了一个 `MyFunctionObject` 类型的对象 `myFunc`，并将其传递给函数调用，就像调用一个普通函数一样。
  * 由于 `myFunc` 是一个函数对象，它包含了状态和数据，因此我们可以在多个地方重复使用它。







# <font color='red'>**回调函数类型**</font>

* <a href="#返回正文24">点击返回正文</a>

* **回调函数类型**是指作为参数传递给函数或者对象的<font color='red'>**函数类型**</font>，以便在某些条件或者事件发生时被调用。在回调函数类型中，通常定义了一个函数指针或者函数对象，用于指向实际的回调函数。
  * <font color='red'>**函数类型**</font>[点击跳转到函数类型](#函数类型)<a id = "返回正文25"></a>
* 例如，在图形用户界面编程中，我们经常需要注册一个回调函数，以便在用户执行某些操作时触发。这个回调函数需要满足特定的函数签名，以便在调用时能够正确处理事件。例如，当用户单击按钮时，我们可以将一个函数指针作为回调函数类型传递给按钮对象，当用户单击按钮时，按钮对象将调用这个函数指针。
* 另外，在网络编程中，我们经常需要注册一个回调函数，以便在某些网络事件发生时被调用。例如，当有数据到达网络套接字时，我们可以将一个函数指针作为回调函数类型传递给套接字对象，以便在数据到达时调用这个函数指针。
* 总之，回调函数类型是一种非常常见的编程技术，它可以实现灵活、可扩展和可重用的代码结构。



# <font color='red'>**函数类型**</font>

* <a href="#返回正文25">点击返回正文</a>

* 函数类型指的是函数的类型，包括参数类型、返回类型和函数签名。

  * **函数签名**是指函数的名称、参数类型和参数个数，**用于唯一标识一个函数**。
  * <font color='red'>**函数签名**</font>[点击跳转到函数签名](#函数签名)<a id = "返回正文27"></a>

* 在C++中，**函数类型**可以表示为一个**函数指针类型**或者一个**函数对象类型**。

  * **函数指针类型指向一个函数**
  * **函数对象类型是一个实现了函数调用运算符()的类**

* 函数类型的定义通常包括参数列表和返回类型。

* 例如，一个函数类型为int(int, float)的函数表示它有两个参数，分别是一个整数和一个浮点数，返回一个整数。在函数类型中，函数签名是由参数类型和返回类型组成的部分，它可以用于唯一确定一个函数类型。

* 函数类型在编程中很常见，常用于<font color='red'>**函数指针**</font>、<font color='red'>**函数对象**</font>、<font color='red'>**模板函数**</font>、<font color='red'>**函数模板特化**</font>等地方。

  * <font color='red'>**函数指针**</font>[点击跳转到函数指针](#函数指针)<a id = "返回正文28"></a>
  * <font color='red'>**函数对象**</font>[点击跳转到函数对象](#函数对象)<a id = "返回正文29"></a>

* 例如，我们可以定义一个<font color='red'>**函数指针类型**</font>，表示指向一个参数为int，返回值为float的函数：

  ```C++
  typedef float (*FuncPtr)(int);
  ```

  * 也可以定义一个<font color='red'>**函数对象类型**</font>，表示实现了参数为int，返回值为float的**函数调用运算符**：

  ```C++
  struct MyFuncObj {
      float operator()(int x) const {
          return x * 1.5;
      }
  };
  ```

  * 总之，函数类型是一个重要的概念，它可以让我们在C++中更加灵活地处理函数，实现**函数指针、函数对象**等高级特性。





# <font color='red'>**函数指针**</font>

* <a href="#返回正文28">点击返回正文</a>

* <a href="#返回正文30">点击返回boost::function</a>

* **函数指针**是指向函数的指针变量，它可以用来间接调用函数。

* **函数指针**的类型由**函数的参数类型**和**返回值类型**决定

* 例如，一个函数指针可以指向一个具有两个整型参数和一个整型返回值的函数，其类型为：

  ```C++
  int (*funcPtr)(int, int);
  ```

  * 其中，`int (*funcPtr)`表示指向一个返回类型为`int`的函数的指针，`(int, int)`表示该函数有两个`int`类型的参数。
  * 因此，`int (*funcPtr)(int, int)`表示一个指向**函数类型**为`int(int, int)`的函数指针。



# <font color='red'>**函数对象**</font>

* <a href="#返回正文29">点击返回正文</a>

* **函数对象**是指实现了函数调用运算符 `operator()` 的类对象。

* 函数对象可以像函数一样被调用，因为它们重载了函数调用运算符，也就是 `operator()` 运算符。因此，函数对象也被称为仿函数。

* 函数对象有以下优点：

  1. 灵活性：函数对象可以保存状态，可以在不同的时间点被多次调用。
     * <font color='red'>**灵活性的理解**</font>[点击跳转到灵活性的理解](#灵活性的理解)<a id = "返回正文30"></a>
  2. 封装性：函数对象可以封装函数及其相关数据，而不需要传递大量的参数。
     * <font color='red'>**封装性的理解**</font>[点击跳转到封装性的理解](#封装性的理解)<a id = "返回正文31"></a>
  3. 泛型编程：函数对象可以被模板函数和模板类使用，从而实现泛型编程。

* 例如，下面的类实现了一个函数对象，可以计算两个数的和：

  ```c++
  class Adder {
  public:
      int operator()(int a, int b) {
          return a + b;
      }
  };
  ```

  * 可以像下面这样使用该函数对象：

  ```C++
  Adder add;
  int sum = add(1, 2); // 等价于 sum = 3
  ```

  * 这里的 `add` 对象就是一个函数对象，它可以像函数一样被调用，实现了两个数的加法运算。





# <font color='red'>**封装性的理解**</font>

* <a href="#返回正文31">点击返回正文</a>

* **封装性**是指将数据和操作数据的方法（函数）封装在一起，形成一个类，**从而达到数据隐藏和保护的目的。**

  * 封装性可以达到数据隐藏和保护的目的，是因为封装将数据和操作数据的方法（函数）作为一个整体来看待，**外界无法直接访问数据，只能通过提供的接口（public成员函数）来进行访问和操作**，从而避免了对数据的误操作和破坏，提高了代码的可靠性和安全性。
  * 另外，**封装性还可以隐藏实现细节**，使得代码更加简洁和易于维护。因为内部实现的细节只有在类内部才会暴露出来，而外界只需要知道如何使用类的接口即可，不需要关心内部实现的细节，从而使得代码更加易于理解和调试。

* 对于**函数对象**而言，它也可以封装函数及其相关数据，将它们组合在一个对象中，并通过对象的接口来使用它们。这种方式可以避免传递大量参数，而将这些参数作为对象的成员变量进行封装，从而简化代码，并提高了代码的可读性和可维护性。

  * 例如，考虑一个计算器类，它可以执行加、减、乘、除四种基本运算。

  * 如果使用函数指针来实现，每次调用函数时都需要传递两个操作数和一个操作符，

  * 这会导致参数的过多和混乱。而如果使用函数对象来实现，我们可以将操作数和操作符作为对象的成员变量，并将四种基本运算作为对象的成员函数，这样每次调用运算时只需要调用对象的成员函数即可，避免了传递大量参数的麻烦。

  * 以下是一个简单的计算器类示例，使用函数对象来封装四种基本运算：

    ```C++
    #include <iostream>
    
    class Calculator {
    public:
        Calculator(double x, double y, char op)
            : x_(x), y_(y), op_(op) {}
    
        double add() const { return x_ + y_; }
        double sub() const { return x_ - y_; }
        double mul() const { return x_ * y_; }
        double div() const { return x_ / y_; }
    
        double compute() const {
            switch (op_) {
                case '+': return add();
                case '-': return sub();
                case '*': return mul();
                case '/': return div();
                default: throw std::invalid_argument("Invalid operator");
            }
        }
    
    private:
        double x_;
        double y_;
        char op_;
    };
    
    int main() {
        Calculator calc(2, 3, '+');
        std::cout << "Result: " << calc.compute() << std::endl;
        return 0;
    }
    ```

    * 在上述示例中，Calculator类封装了两个操作数x和y，以及一个操作符op，并将四种基本运算（add、sub、mul和div）封装为成员函数。compute函数根据操作符的类型选择适当的运算函数来计算结果。这种设计方式避免了大量参数的传递，并保证了数据的封装和安全性。

* `throw`是C++中用于抛出异常的关键字。

  * 当程序运行时发生了意外情况，导致无法继续执行下去时，可以使用`throw`抛出异常，使程序跳转到异常处理程序。
  * 在使用`throw`抛出异常时，需要指定一个异常对象，通常是一个类的对象，表示异常的类型和相关信息。
    * 例如，我们可以定义一个`MyException`类，用于表示某个错误的异常，并在需要抛出异常时创建一个`MyException`对象并将其作为参数传递给`throw`。
  * 下面是一个简单的例子，演示了如何使用`throw`抛出异常：

  ```c++
  #include <iostream>
  #include <string>
  
  class MyException {
  public:
      MyException(const std::string& msg) : message(msg) {}
      const std::string& getMessage() const { return message; }
  private:
      std::string message;
  };
  
  void doSomething(int value) {
      if (value < 0) {
          throw MyException("Value must be non-negative");
      }
      // do something
  }
  
  int main() {
      int value;
      std::cin >> value;
      try {
          doSomething(value);
      }
      catch (const MyException& e) {
          std::cerr << "Exception caught: " << e.getMessage() << std::endl;
      }
      return 0;
  }
  ```

  * 在上面的例子中，`doSomething`函数用于执行某些操作，如果输入的参数小于0，则会抛出一个`MyException`异常。
  * 在`main`函数中，我们使用`try-catch`语句捕获可能抛出的异常，并打印出异常信息。

* `try-catch`语句是C++中的异常处理机制。

  * `try`块中的代码尝试执行可能会引发异常的操作。
  * 如果异常确实被引发，程序将跳转到与之匹配的catch块。
  * catch块中的代码可以捕获异常并对其进行处理，比如打印错误信息、恢复程序状态等等。

  下面是一个`try-catch`语句的示例：

  ```c++
  try {
      // 可能会抛出异常的代码
  } catch (const std::exception& e) {
      // 异常处理代码
  }
  ```

  * 在这个示例中，try块中的代码可能会抛出异常，如果确实抛出了异常，程序将跳转到catch块中进行异常处理。catch块的参数是一个常量引用，类型为std::exception，它表示捕获任何类型的异常。在catch块中，我们可以访问异常对象并对其进行处理，比如打印错误信息。

  * 注意，try-catch语句只能捕获在try块中抛出的异常，不能捕获在其它线程中抛出的异常。另外，catch块可以有多个，每个catch块可以捕获不同类型的异常。如果多个catch块可以捕获同一类型的异常，那么它们将按照出现顺序依次被调用。











# <font color='red'>**灵活性的理解**</font>

* <a href="#返回正文30">点击返回正文</a>

* 函数对象和函数指针的一个重要区别是函数对象可以包含状态。

* 函数对象可以在构造时接受一些参数，并在执行时使用这些参数来计算结果。

* 这种能力使得函数对象在某些情况下比函数指针更加灵活。

* 举个例子，假设我们有一个函数，它需要一个参数n，然后计算前n个整数的和。如果我们使用函数指针，我们需要在每次调用函数时都提供参数n。但是如果我们使用函数对象，则可以在构造函数中传递n作为参数，并在之后的每次调用中重用该对象。这使得代码更加简洁和易于维护。

* 另一个例子是事件处理程序。当事件发生时，我们需要调用事件处理程序函数，并传递一些参数。如果我们使用函数指针，我们需要在每次调用事件处理程序时都重新传递相同的参数。但是如果我们使用函数对象，则可以在构造时将参数保存在对象中，并在之后的每次调用中重用该对象。这种能力使得事件处理程序更加灵活和易于使用。

  * 在事件处理程序中，我们需要调用一个特定的函数来响应事件，并且通常需要传递一些参数。如果我们使用函数指针来实现事件处理程序，我们需要在每次调用函数时都重新传递相同的参数。这样可能会导致代码变得冗长和难以维护。但是，如果我们使用函数对象，我们可以将需要传递的参数保存在对象中，并在之后的每次调用中重用该对象。这样可以使事件处理程序更加灵活和易于使用，因为我们可以在处理不同事件时使用不同的参数，而无需每次都重新传递。

  * 以下是一个简单的示例，其中定义了一个名为`EventHandler`的函数对象类，它具有保存事件处理程序所需参数的成员变量，并重载了“()”运算符以便用于事件处理：

    ```C++
    #include <iostream>
    
    class EventHandler {
    public:
        EventHandler(int param) : m_param(param) {}
    
        void operator()() const {
            std::cout << "Event handler called with parameter " << m_param << std::endl;
        }
    
    private:
        int m_param;
    };
    
    int main() {
        // 创建一个事件处理程序对象并传递参数
        EventHandler eventHandler(42);
    
        // 在事件发生时调用事件处理程序
        eventHandler();
        // 输出: Event handler called with parameter 42
    
        return 0;
    }
    ```

    * 在这个示例中，我们创建了一个名为`eventHandler`的`EventHandler`对象，并将42作为参数传递给它的构造函数。
    * 然后，我们使用圆括号运算符调用该对象，这实际上会调用重载的“()”运算符，并打印出一条消息，其中包含保存的参数。
    * 这样，我们就可以将事件处理程序对象传递给其他函数或库，并在事件发生时重复使用它，而无需在每次调用时都重新传递参数。

* 因此，函数对象相比函数指针在某些情况下更具灵活性，因为它们可以保存状态，并在不同的时间点被多次调用。

* 举个例子，假设我们有一个函数`SumN`，它需要一个参数`n`，然后计算前`n`个整数的和。

  * 如果我们使用函数指针实现：

  ```C++
  int SumN(int n, int (*f)(int)) {
      int sum = 0;
      for (int i = 1; i <= n; i++) {
          sum += f(i);
      }
      return sum;
  }
  
  int Identity(int n) {
      return n;
  }
  
  int main() {
      int n = 5;
      int sum = SumN(n, Identity);
      // sum = 1 + 2 + 3 + 4 + 5 = 15
      return 0;
  }
  ```

  * 我们需要在每次调用函数时都提供参数`n`，这会造成代码的冗余。

  * 但是如果我们使用函数对象实现：

  ```c++
  class SumN {
  public:
      SumN(int n) : n_(n) {}
      int operator()(int i) const {
          return i;
      }
  private:
      int n_;
  };
  
  int main() {
      int n = 5;
      SumN sum_n(n);
      int sum = 0;
      for (int i = 1; i <= n; i++) {
          sum += sum_n(i);
      }
      // sum = 1 + 2 + 3 + 4 + 5 = 15
      return 0;
  }
  ```

  * 我们可以在构造函数中传递`n`作为参数，并在之后的每次调用中重用该对象，这使得代码更加简洁和易于维护。





# <font color='red'>**公开继承**</font>

* <a href="#返回正文1">点击返回正文</a>

* 公开继承是C++中一种继承方式，它允许子类（派生类）**继承**基类（父类）的**所有公共成员**（包括变量和函数），并在其基础上添加自己的成员。

* 在公开继承中，基类的公共成员对于派生类来说是可见和可访问的。派生类可以使用基类的公共成员，也可以在其基础上添加新的成员，从而实现代码的复用和扩展。

* 公开继承使用关键字` public`来定义，如下所示：

  ```c++
  class DerivedClass : public BaseClass
  {
      // DerivedClass的成员
  };
  ```

* 在上述代码中`DerivedClass`是派生类，`BaseClass`是基类。通过使用`public`关键字，`DerivedClass`可以公开继承`BaseClass`的所有公共成员。





# <font color='red'>**virtual虚函数**</font>

* <a href="#返回正文2">点击返回正文</a>

* 在C++中，`virtual`是一种关键字，用于声明一个函数为虚函数。

* **虚函数是指在基类中声明为虚函数的函数，在派生类中可以被重新定义（覆盖）的一种特殊函数。**

* **纯虚函数**的声明格式为：

  ```C++
  virtual return_type function_name(parameter_list) = 0;
  ```

  * 等号后面的`0`表示纯虚函数，表示**该函数没有实现，派生类必须实现该函数才能被实例化**。

* 虚函数主要用于实现<font color='red'>**多态**</font>。[点击跳转到多态](#多态)<a id="返回正文3"></a>

* 当一个函数被声明为虚函数后，派生类可以重新定义该函数，从而实现在不同的上下文环境中使用不同的函数实现。

* 通过基类的指针或引用调用虚函数时，程序会自动选择调用基类或派生类的函数实现，从而实现多态。

* 需要注意的是，**只有类的成员函数才能被声明为虚函数，而全局函数和静态函数不能被声明为虚函数。**

* **普通虚函数和纯虚函数**都是虚函数的一种，不同之处在于：

  * 普通虚函数有函数实现，而**纯虚函数没有函数实现**。
  * **纯虚函数必须被派生类实现**，而普通虚函数不必被派生类实现。
  * 普通虚函数的定义格式和调用方式与普通函数相同，只是在声明时加上"virtual"关键字即可。如下所示：

  ```C++
  class BaseClass {
  public:
      virtual void virtualFunc() {
          // 普通虚函数实现
      }
  };
  ```

  * **在派生类中重新定义普通虚函数**时，可以选择是否调用基类的虚函数实现：

  ```C++
  class DerivedClass : public BaseClass {
  public:
      void virtualFunc() {
          // 重新定义普通虚函数实现
          BaseClass::virtualFunc(); // 调用基类的虚函数实现
      }
  };
  ```

  * **纯虚函数**的定义格式如下：

  ```C++
  class BaseClass {
  public:
      virtual void pureVirtualFunc() = 0;
  };
  ```

  * 在上述代码中，函数声明后面跟着"= 0"，表示该函数是纯虚函数。**纯虚函数没有函数实现，必须在派生类中被实现才能被调用。如果一个类中有纯虚函数，那么该类就是抽象类，不能被实例化，只能作为基类被继承。**
  * **派生类必须实现基类中的纯虚函数，否则它也会变成抽象类。**
  * 在实现纯虚函数时，需要使用和基类中纯虚函数相同的函数签名。例如：

  ```C++
  class DerivedClass : public BaseClass {
  public:
      void pureVirtualFunc() {
          // 重新定义纯虚函数实现
      }
  };
  ```

  * 在上述代码中，`DerivedClas`类必须实现基类中的纯虚函数`pureVirtualFunc()`，否则`DerivedClass`也会变成抽象类。





# <font color='red'>**多态**</font>

* <a href="#返回正文3">点击返回正文</a>

* **C++中的多态是指在运行时根据实际的对象类型来确定调用哪个函数的能力**，主要是通过虚函数来实现的。

* 在C++中，通过在基类中将函数声明为虚函数，在派生类中重新定义虚函数，实现在不同的上下文环境中使用不同的函数实现。

* 通过基类的指针或引用调用虚函数时，程序会自动选择调用基类或派生类的函数实现，从而实现多态。

* C++中的多态主要有两种实现方式：动态多态和静态多态。

  * **动态多态**
    * 动态多态是指在**程序运行**时才能确定要调用哪个函数的多态，也称为运行时多态。它主要通过虚函数和指针或引用来实现。例如：

  ```C++
  class Animal {
  public:
      virtual void speak() {
          cout << "This is the virtual function in Animal." << endl;
      }
  };
  
  class Cat : public Animal {
  public:
      void speak() {
          cout << "This is the virtual function in Cat." << endl;
      }
  };
  
  int main() {
      Animal* animalPtr = new Cat();
      animalPtr->speak(); // 运行时调用Cat的speak()函数
      return 0;
  }
  ```

  * 在上述代码中，通过基类的指针`animalPtr`调用虚函数`speak()`时，程序会自动选择调用Cat的虚函数实现，从而实现动态多态。
  * **静态多态**
    * 静态多态是指在**程序编译**时就能确定要调用哪个函数的多态，也称为编译时多态。它主要通过函数重载和模板来实现。例如：

  ```C++
  void print(int a) {
      cout << "This is the function with one parameter." << endl;
  }
  
  void print(int a, int b) {
      cout << "This is the function with two parameters." << endl;
  }
  
  template<typename T>
  void print(T a) {
      cout << "This is the template function." << endl;
  }
  
  int main() {
      print(1); // 静态调用print(int a)函数
      print(1, 2); // 静态调用print(int a, int b)函数
      print("Hello, World!"); // 静态调用print(T a)函数
      return 0;
  }
  ```

  * 在上述代码中，通过<font color='red'>**函数重载**</font>和<font color='red'>**模板**</font>实现静态多态。在编译时，程序就能确定要调用哪个函数，从而实现静态多态。
    * <font color='red'>**函数重载**</font>[点击跳转到函数重载](#函数重载)<a id = "返回正文4"></a>
    * <font color='red'>**模板**</font>[点击跳转到模板](#模板)<a id = "返回正文5"></a>
  * 总的来说，C++中的多态是通过虚函数来实现的，通过基类的指针或引用调用虚函数时，程序会自动选择调用基类或派生类的函数实现，从而实现多态。动态多态和静态多态分别通过虚函数和函数重载或模板来实现。



# <font color='red'>**函数重载**</font>

* <a href="#返回正文4">点击返回正文</a>

* <a href="#返回正文17">点击返回函数签名正文</a>

* **函数重载**是指在一个类或<font color='red'>**命名空间**</font>中**定义多个名称相同但参数列表不同的函数，编译器通过匹配函数调用时提供的参数类型和数量来确定调用哪个函数。**

  * <font color='red'>**命名空间**</font>[点击跳转到命名空间](#命名空间)<a id = "返回正文6"></a>
  * 函数重载可以增加程序的可读性和可维护性，避免在不同情况下使用不同的函数名称，从而减少代码量。

* **函数重载的规则：**

  1. 函数名称相同。
  2. 参数列表必须不同，可以是参数的个数、类型或顺序不同。
  3. 函数的返回值类型可以相同也可以不同，但不能仅仅是返回类型不同。

* 例如，下面是一个简单的函数重载例子：

  ```C++
  #include <iostream>
  
  void print(int x) {
      std::cout << "The integer is " << x << std::endl;
  }
  
  void print(double x) {
      std::cout << "The double is " << x << std::endl;
  }
  
  int main() {
      print(5);
      print(3.14);
      return 0;
  }
  ```

  * 在上面的例子中，定义了两个名为`print`的函数，分别接收一个`int`和一个`double`类型的参数。根据调用时提供的参数类型，编译器会选择相应的函数进行调用。
  * 需要注意的是，函数重载不能仅仅依赖于函数的返回类型，因为编译器在决定调用哪个函数时，只会考虑参数列表而不会考虑返回类型。
  * 函数重载也可以在类中使用，称为成员函数重载。在类中使用成员函数重载时，函数的参数列表不仅包括函数参数，还包括隐式的`this`指针，用于指向当前对象。例如：

  ```C++
  class MyClass {
  public:
      void print(int x) {
          std::cout << "The integer is " << x << std::endl;
      }
  
      void print(double x) {
          std::cout << "The double is " << x << std::endl;
      }
  };
  
  int main() {
      MyClass obj;
      obj.print(5);
      obj.print(3.14);
      return 0;
  }
  ```

  * 在上面的例子中，`MyClass`类中定义了两个名为`print`的成员函数，分别接收一个`int`和一个`double`类型的参数。
  * 在调用时，编译器会自动将当前对象的地址作为`this`指针传递给函数。



# <font color='red'>**模板**</font>

* <a href="#返回正文5">点击返回正文</a>

* 模板是C++中的一个重要特性，它允许编写通用代码，即可以**处理多种数据类型的代码**。使用模板可以提高代码的复用性和灵活性。

* **模板**可以分为**函数模板**和**类模板**两种。

* **函数模板：**

  * **函数模板是一种通用的函数定义，可以在不指定具体类型的情况下，使用同一份代码处理多种数据类型。**
  * 函数模板的定义格式为：

  ```c++
  template<typename T>
  返回类型 函数名称(参数列表) {
      // 函数体
  }
  ```

  * 其中，`typename T`是类型参数声明，`T`是类型参数名称。
  * 在函数调用时，`T`将被具体的类型替换。

  * 例如，下面是一个函数模板示例：

  ```C++
  #include <iostream>
  
  template<typename T>
  void swap(T& a, T& b) {
      T temp = a;
      a = b;
      b = temp;
  }
  
  int main() {
      int x = 5, y = 10;
      std::cout << "Before swap: x=" << x << ", y=" << y << std::endl;
      swap(x, y);
      std::cout << "After swap: x=" << x << ", y=" << y << std::endl;
      return 0;
  }
  ```

  * 在上面的例子中，`swap`是一个函数模板，用于交换两个变量的值。函数模板定义中的`typename T`表示`T`是一个类型参数，`T& a`和`T& b`表示两个引用参数的类型都是`T`。在调用`swap`函数时，编译器会根据参数的类型自动推导出`T`的具体类型。

    

* **类模板：**
  * 类模板与函数模板类似，允许定义一个通用的类，可以处理多种数据类型。类模板的定义格式为：

```C++
template<typename T>
class 类名称 {
public:
    // 成员函数和变量
};
```

* 其中，`typename T`是类型参数声明，`T`是类型参数名称。

* 在类定义中，可以使用类型参数`T`来定义成员变量、成员函数等。

  

例如，下面是一个类模板示例：

```C++
#include <iostream>

template<typename T>
class Stack {
private:
    T data[100];
    int top;
public:
    Stack() {
        top = -1;
    }

    void push(T value) {
        data[++top] = value;
    }

    T pop() {
        return data[top--];
    }

    bool empty() const {
        return top == -1;
    }
};

int main() {
    Stack<int> s1;
    s1.push(1);
    s1.push(2);
    std::cout << s1.pop() << std::endl; // 2
    std::cout << s1.pop() << std::endl; // 1

    Stack<double> s2;
    s2.push(1.23);
    s2.push(4.56);
    std::cout << s2.pop() << std::endl; // 4.56
    std::cout << s2.pop() << std::endl; // 1.23

    return 0;
}
```

在上面的例子中，`Stack`是一个类模





# <font color='red'>**命名空间**</font>

* <a href="#返回正文6">点击返回正文</a>

* **命名空间**是C++中用来**解决命名冲突的机制**。

* **它可以将一些具有相同名称的变量、函数、类等放在同一个命名空间下，以便在不同的作用域中使用它们而不会出现命名冲突。**

  * 在C++中，如果在不同的<font color='red'>**作用域**</font>中定义了相同名称的变量、函数、类等，就会发生命名冲突，编译器无法判断使用哪个定义。

    * <font color='red'>**作用域**</font>[点击跳转到作用域](#作用域)<a id = "返回正文8"></a>

  * 例如，假设在一个程序中有两个文件，每个文件中都定义了一个名为`foo`的函数：

    ```C++
    // file1.cpp
    void foo() {
        // ...
    }
    
    // file2.cpp
    void foo() {
        // ...
    }
    ```

    * 当这两个文件被编译链接成一个可执行文件时，就会发生命名冲突，编译器无法判断在调用`foo`函数时使用哪个定义。这时候就需要使用命名空间来解决命名冲突。
    * 命名空间就像是一个容器，可以将具有相同名称的变量、函数、类等放在同一个容器中，以便在不同的作用域中使用它们而不会发生命名冲突。例如，可以在`file1.cpp`和`file2.cpp`中分别定义属于不同命名空间的`foo`函数：

    ```C++
    // file1.cpp
    namespace ns1 {
        void foo() {
            // ...
        }
    }
    
    // file2.cpp
    namespace ns2 {
        void foo() {
            // ...
        }
    }
    ```

    * 在另一个文件中使用这些函数时，需要指定函数所属的命名空间：

    ```C++
    #include <iostream>
    
    // 引入命名空间
    using namespace ns1;
    using namespace ns2;
    
    int main() {
        ns1::foo(); // 调用ns1命名空间中的foo函数
        ns2::foo(); // 调用ns2命名空间中的foo函数
        return 0;
    }
    ```

    * 在上面的示例中，`ns1`和`ns2`是两个不同的命名空间，分别包含了一个名为`foo`的函数。在`main`函数中，使用`using namespace`来引入命名空间，然后使用`namespace::`的语法来访问命名空间中的变量和函数，以避免命名冲突。

* 命名空间可以使用`namespace`关键字来定义，其基本语法如下：

  ```c++
  namespace 命名空间名称 {
      // 命名空间中的变量、函数、类等定义
  }
  ```

* 例如，下面是一个简单的命名空间示例：

  ```C++
  #include <iostream>
  
  namespace mynamespace {
      int x = 1;
      void func() {
          std::cout << "Hello, world!" << std::endl;
      }
  }
  
  int main() {
      std::cout << mynamespace::x << std::endl; // 1
      mynamespace::func(); // Hello, world!
      return 0;
  }
  ```

  * 在上面的例子中，`mynamespace`是一个命名空间，包含了一个变量`x`和一个函数`func`。在`main`函数中，可以通过`mynamespace::x`和`mynamespace::func()`来访问命名空间中的变量和函数。
  * 另外，命名空间也可以使用`using`关键字来引入，例如：

  ```C++
  #include <iostream>
  
  namespace mynamespace {
      int x = 1;
  }
  
  using mynamespace::x;
  
  int main() {
      std::cout << x << std::endl; // 1
      return 0;
  }
  ```

  * 在上面的例子中，通过`using mynamespace::x`将`mynamespace`命名空间中的`x`引入到`main`函数中，从而可以直接使用`x`而不需要加上命名空间前缀。注意，在使用`using`引入命名空间的时候，应该尽量避免出现命名冲突。



# <font color='red'>**作用域**</font>

* <a href="#返回正文8">点击返回正文</a>

* 在C++中，**作用域是指一个变量或者一个函数能够被**<font color='red'>**访问**</font>**的范围**

  * <font color='red'>**访问**</font>[点击跳转到访问](#访问)<a id = "返回正文9"></a>

* C++中有以下几种作用域：

  * **全局作用域**
  * **全局作用域**包括**整个程序**的范围，可以在程序中的任何地方使用全局变量和函数。
  
```C++
  #include <iostream>
  
  // 全局变量
  int global_variable = 42;
  
  // 全局函数
  void global_function() {
      std::cout << "This is a global function." << std::endl;
  }
  
  int main() {
      // 在main函数中访问全局变量和函数
      std::cout << "The value of global_variable is " << global_variable << std::endl;
      global_function();
      return 0;
  }
```

* **命名空间作用域**
    * **命名空间作用域**指在命名空间中定义的变量和函数，可以通过**命名空间限定符**`::`来访问。

  ```C++
  #include <iostream>
  
  namespace my_namespace {
      // 命名空间作用域中的变量和函数
      int x = 10;
      void foo() {
          std::cout << "This is a function in my_namespace." << std::endl;
      }
  }
  
  int main() {
      // 在main函数中访问my_namespace中的变量和函数
      std::cout << "The value of my_namespace::x is " << my_namespace::x << std::endl;
      my_namespace::foo();
      return 0;
  }
  ```
  
  * **局部作用域**
  * **局部作用域指在函数、循环、语句块中定义的变量和函数，只能在定义它们的函数、循环、语句块中访问。**
  
```C++
  #include <iostream>

  void my_function() {
      // 在函数中定义的变量和函数只能在函数内部访问
      int x = 20;
      void bar() {
          std::cout << "This is a local function." << std::endl;
      }
      std::cout << "The value of x is " << x << std::endl;
      bar();
  }
  
  int main() {
      my_function();
      return 0;
  }
```

  * 在上述示例中，`my_function`函数中定义了一个局部变量`x`和一个局部函数`bar`，它们只能在`my_function`函数中访问。
  * **作用域决定了变量和函数的可见性和生命周期。全局变量和函数的生命周期和程序的生命周期一样长，而局部变量和函数的生命周期只在定义它们的作用域内有效。命名空间的作用域可以跨越多个文件，它们的生命周期也和程序的生命周期一样长。**






# <font color='red'>**访问**</font>

* <a href="#返回正文9">点击返回正文</a>

* 在C++中，**访问是指代码中的某个部分可以访问另一个部分的能力**。

* C++中有以下几种访问：

  * **公有访问**
    * **公有访问是指一个类中的公有成员可以被该类的对象、该类的派生类的对象以及外部函数访问。使用关键字`public`来声明公有成员。**

  ```C++
  class MyClass {
  public:
      // 公有成员函数
      void myPublicFunction() {
          std::cout << "This is a public member function." << std::endl;
      }
  public:
      // 公有数据成员
      int myPublicVariable;
  };
  
  int main() {
      MyClass obj;
      obj.myPublicFunction(); // 可以访问公有成员函数
      obj.myPublicVariable = 10; // 可以访问公有数据成员
      return 0;
  }
  ```

  * **私有访问**
    * **私有访问是指一个类中的私有成员只能被该类的对象和该类的**<font color='red'>**友元函数**</font >**访问，不能被派生类和外部函数访问。使用关键字`private`来声明私有成员。**
      * <font color='red'>**友元函数**</font>[点击跳转到友元函数](#友元函数)<a id = "返回正文10"></a>
  
  ```c++
  class MyClass {
  private:
      // 私有成员函数
      void myPrivateFunction() {
          std::cout << "This is a private member function." << std::endl;
      }
  private:
      // 私有数据成员
      int myPrivateVariable;
  };
  
  int main() {
      MyClass obj;
      obj.myPrivateFunction(); // 编译错误，不能访问私有成员函数
      obj.myPrivateVariable = 10; // 编译错误，不能访问私有数据成员
      return 0;
  }
  ```
  
  * **保护访问**
    * **保护访问是指一个类中的保护成员可以被该类的对象、该类的派生类的对象以及该类的友元函数访问，但是不能被外部函数访问。使用关键字`protected`来声明保护成员。**
  
  ```C++
  class MyClass {
  protected:
      // 保护成员函数
      void myProtectedFunction() {
          std::cout << "This is a protected member function." << std::endl;
      }
  protected:
      // 保护数据成员
      int myProtectedVariable;
  };
  
  class MyDerivedClass : public MyClass {
  public:
      void myFunction() {
          myProtectedFunction(); // 可以访问基类的保护成员函数
          myProtectedVariable = 20; // 可以访问基类的保护数据成员
      }
  };
  
  int main() {
      MyDerivedClass obj;
      obj.myFunction();
      return 0;
  }
  ```
  
  * 在上述示例中，`MyDerivedClass`是`MyClass`的公有派生类，因此可以访问`MyClass`的保护成员函数和保护数据成员。



# <font color='red'>**友元函数**</font>

* <a href="#返回正文10">点击返回正文</a>

* **友元函数是一个定义在类外部、但有权访问类私有成员的函数。**

* **友元函数不是类的成员函数，但是可以访问类中的非公有成员（包括私有成员和保护成员）。**

* 在C++中，可以使用关键字`friend`来将一个函数声明为友元函数。在类中使用`friend`关键字声明的函数可以访问该类的私有成员和保护成员，但不是类的成员函数。因此，友元函数不能通过<font color='red'>**类的对象调用**</font>，而是直接使用函数名进行调用。

  * <font color='red'>**类的对象调用**</font>[点击跳转到类的对象调用](#类的对象调用)<a id = "返回正文11"></a>

* 下面是一个简单的示例：

  ```C++
  #include <iostream>
  using namespace std;
  
  class MyClass {
      private:
          int num1;
          int num2;
      public:
          MyClass(int a = 0, int b = 0) : num1(a), num2(b) {}
          friend int Sum(MyClass obj); // 声明Sum为友元函数
  };
  
  int Sum(MyClass obj) { // 友元函数
      int result = obj.num1 + obj.num2;
      return result;
  }
  
  int main() {
      MyClass obj(10, 20);
      cout << "Sum = " << Sum(obj) << endl; // 调用友元函数
      return 0;
  }
  ```

  * 在上述示例中，我们声明了一个名为`Sum`的函数为`MyClass`类的友元函数。该函数可以访问`MyClass`类的私有成员`num1`和`num2`。在`main`函数中，我们创建了一个`MyClass`类的对象`obj`，并使用`Sum`函数来计算它的两个成员变量的和。
  * 需要注意的是，虽然友元函数可以访问类的私有成员和保护成员，但是不应该滥用友元函数，因为这会破坏类的封装性和安全性。友元函数应该只在有必要的情况下使用，以避免出现不必要的耦合和安全问题。



# <font color='red'>**类的对象调用**</font>

* <a href="#返回正文11">点击返回正文</a>

* 类的对象调用是指使用对象来调用该类的成员函数或访问该类的成员变量。在C++中，使用点号`.`来访问对象的成员变量或成员函数。

* 下面是一个简单的示例，演示如何使用对象调用类的成员函数和成员变量：

  ```C++
  #include <iostream>
  using namespace std;
  
  class MyClass {
      private:
          int num1;
      public:
          MyClass(int a = 0) : num1(a) {}
          void display() {
              cout << "num1 = " << num1 << endl;
          }
  };
  
  int main() {
      MyClass obj(10);
      obj.display(); // 使用对象调用成员函数
      cout << "num1 = " << obj.num1 << endl; // 使用对象访问成员变量
      return 0;
  }
  ```

  * `MyClass(int a = 0) : num1(a) {}`
    * `MyClass(int a = 0) : num1(a) {}` 是一个构造函数，用于创建`MyClass`类的对象。
    * **构造函数在对象创建时自动调用，并初始化对象的成员变量**。
    * 在这个构造函数中，我们使用了<font color='red'>**成员初始化列表**</font>的方式对成员变量`num1`进行初始化，这种方式可以提高效率并避免一些错误。
      * <font color='red'>**成员初始化列表**</font>[点击跳转到成员初始化列表](#成员初始化列表)<a id = "返回正文12"></a>
    * 成员初始化列表使用冒号`:`来引出，后跟一个<font color='red'>**成员初始化器列表**</font>，用逗号分隔每个成员的初始化。
    * 具体来说，`int a = 0`是构造函数的参数列表，表示创建对象时可以传入一个整数参数，如果没有传入则默认为0
    * `num1(a)`则是成员初始化列表中的成员初始化器，表示将`num1`的值初始化为构造函数参数`a`的值。
    * 因此，这个构造函数可以用于创建一个`MyClass`对象，并将`num1`成员变量初始化为传入的参数值或0。
  * 在上述示例中，我们定义了一个名为`MyClass`的类，并创建了一个名为`obj`的对象。我们使用对象`obj`调用了类的成员函数`display()`，并使用对象`obj`访问了类的成员变量`num1`。
  * 需要注意的是，只有在对象被创建后才能使用点号来访问它的成员变量或成员函数。如果在对象创建之前使用点号访问成员变量或成员函数，将会导致编译错误。



# <font color='red'>**成员初始化列表**</font>

* <a href="#返回正文12">点击返回正文</a>

* **成员初始化列表**是在C++类构造函数中用于初始化成员变量的语法结构，它由一个冒号 `:` 后面跟随一个用逗号分隔的<font color='red'>**初始化器列表**</font>组成。

  * <font color='red'>**初始化器列表**</font>[点击跳转到初始化器列表](#初始化器列表)<a id = "返回正文13"></a>

* 例如，下面是一个使用成员初始化列表的简单示例：

  ```C++
  #include <iostream>
  using namespace std;
  
  class MyClass {
      private:
          int num1;
          int num2;
      public:
          MyClass(int a, int b) : num1(a), num2(b) {
              cout << "Constructor called" << endl;
          }
          void display() {
              cout << "num1 = " << num1 << endl;
              cout << "num2 = " << num2 << endl;
          }
  };
  
  int main() {
      MyClass obj(10, 20);
      obj.display();
      return 0;
  }
  ```

  * 在上述示例中，我们定义了一个名为`MyClass`的类，包含两个整型成员变量`num1`和`num2`。
  * 我们使用成员初始化列表的方式对这两个成员变量进行了初始化，构造函数的代码块中只输出了一条信息。在`main()`函数中，我们创建了一个`MyClass`对象`obj`，并调用了它的成员函数`display()`，输出了成员变量的值。
  * 使用成员初始化列表可以提高效率和可读性，因为它能够在对象创建时一次性完成所有成员变量的初始化，并且在语法上更加简洁明了。另外，对于**const成员变量或引用类型成员变量，必须使用成员初始化列表进行初始化，否则编译将报错。**



# <font color='red'>**初始化器列表**</font>

* <a href="#返回正文13">点击返回正文</a>

* **初始化器列表**是一种在C++中用于初始化数组和结构体成员的语法结构，它由花括号 `{}` 包含，内部用逗号分隔各个元素的值或键值对。初始化器列表可以用于对数组和结构体的成员进行初始化，也可以用于对标准库容器的元素进行初始化。

* 例如，下面是一个**使用初始化器列表对数组进行初始化**的简单示例：

  ```C++
  #include <iostream>
  using namespace std;
  
  int main() {
      int arr[5] = {1, 2, 3, 4, 5};
      for(int i=0; i<5; i++) {
          cout << arr[i] << " ";
      }
      cout << endl;
      return 0;
  }
  ```

  * 在上述示例中，我们定义了一个包含5个整型元素的数组`arr`，并使用初始化器列表对其进行了初始化。
  * 在`main()`函数中，我们使用`for`循环遍历数组并输出每个元素的值。

* 除了数组之外，我们还可以**使用初始化器列表对结构体的成员**进行初始化，例如：

  ```C++
  struct Point {
      int x;
      int y;
  };
  
  int main() {
      Point p = {10, 20};
      cout << "x = " << p.x << ", y = " << p.y << endl;
      return 0;
  }
  ```

  * 在上述示例中，我们定义了一个包含两个整型成员变量`x`和`y`的结构体`Point`，并使用初始化器列表对其进行了初始化。在`main()`函数中，我们创建了一个`Point`对象`p`并输出了其成员变量的值。

  * **初始化器列表对标准库容器的元素进行初始化**，例如：

  ```C++
  #include <iostream>
  #include <vector>
  using namespace std;
  
  int main() {
      vector<int> v = {1, 2, 3, 4, 5};
      for(int i=0; i<v.size(); i++) {
          cout << v[i] << " ";
      }
      cout << endl;
      return 0;
  }
  ```

  * 在上述示例中，我们定义了一个包含5个整型元素的`vector`容器`v`，并使用初始化器列表对其进行了初始化。在`main()`函数中，我们使用`for`循环遍历容器并输出每个元素的值。



# <font color='red'>**函数类型**</font>

* <a href="#返回正文14">点击返回正文</a>
* **函数类型**指的是函数的“签名”，**包括函数的参数类型和返回类型**。
* 函数类型可以用函数指针类型或者函数对象类型来表示。
* 例如，一个函数类型为`int (*)(int, int)`，表示参数为两个`int`类型的整数，返回值为`int`类型的函数指针类型。
* 一个函数类型为`struct Add { int operator()(int a, int b) const { return a + b; } };`，表示参数为两个`int`类型的整数，返回值为`int`类型的函数对象类型。





# <font color='red'>**函数类型是一个函数指针类型的语法糖**</font>

* <a href="#返回正文15">点击返回正文</a>

* 函数类型是指一个<font color='red'>**函数的签名**</font>，包括参数列表和返回值类型，可以看作是一种类型。

  * <font color='red'>**函数签名**</font>[点击跳转到函数签名](#函数签名)<a id = "返回正文16"></a>

* 函数指针类型是指一个指向函数的指针，它也包括函数的签名信息。

  在C++中，函数类型和函数指针类型有着相似的声明语法，但它们是不同的类型。当我们使用函数类型作为函数的参数或返回值类型时，实际上是声明了一个函数指针类型的形参或返回值。这种用法是一种语法糖，即让我们可以方便地使用函数类型来表示函数指针类型，而不必显式地写出函数指针类型的声明语句。

  例如，在以下代码中，声明了一个函数类型`FuncType`，它的参数为两个整数，返回值为一个整数：

  ```
  typedef int FuncType(int, int);
  ```

  现在我们可以使用`FuncType`作为一个函数指针类型，例如：

  ```
  csharpCopy codeint add(int x, int y) {
      return x + y;
  }
  
  int main() {
      FuncType* funcPtr = &add;
      int result = (*funcPtr)(1, 2);
      return 0;
  }
  ```

  在这个例子中，我们声明了一个函数指针变量`funcPtr`，它的类型为`FuncType*`，即一个指向参数为两个整数、返回值为一个整数的函数的指针。我们将`add`函数的地址赋值给了`funcPtr`，然后通过函数指针调用`add`函数并返回结果。



# <font color='red'>**函数签名**</font>

* <a href="#返回正文16">点击返回正文</a>

* <a href="#返回正文27">点击返回函数签名正文</a>

* **函数签名**是指函数的名称、参数类型和参数个数，用于唯一标识一个函数。

* 函数签名不包括函数返回类型和`const/volatile`修饰符。

* 在C++中，函数签名用于**函数重载**的决策，**即在多个函数名相同但参数不同的函数中**选择正确的函数调用。

  * <font color='red'>**函数重载**</font>[点击跳转到函数重载](#函数重载)<a id = "返回正文17"></a>

* **如果两个函数具有相同的名称和参数类型，但返回类型不同，它们被认为是不同的函数，因为函数签名不包括返回类型。**

  * <font color='red'>**如果两个函数具有相同的名称和参数类型，但返回类型不同，它们被认为是不同的函数，因为函数签名不包括返回类型。**</font>[点击跳转到如果两个函数具有相同的名称和参数类型，但返回类型不同，它们被认为是不同的函数，因为函数签名不包括返回类型。](#函数重载)<a id = "返回正文18"></a>

* 下面是一个函数签名的例子：

  ```
  sqlCopy code
  int add(int a, int b); // 函数签名为 add(int, int)
  ```

  这里函数的名称为`add`，参数类型为两个整数`int`，因此函数签名为`add(int, int)`。

  函数签名还可以包括异常规范，例如：

  ```
  cCopy code
  int divide(int a, int b) throw(std::runtime_error); // 函数签名为 divide(int, int) throw(std::runtime_error)
  ```

  这里函数的名称为`divide`，参数类型为两个整数`int`，并且它声明了抛出`std::runtime_error`异常，因此函数签名为`divide(int, int) throw(std::runtime_error)`。



# <font color='red'>**如果两个函数具有相同的名称和参数类型，但返回类型不同，它们被认为是不同的函数，因为函数签名不包括返回类型**</font>

* <a href="#返回正文18">点击返回正文</a>

* 在C++中，如果两个函数具有相同的名称和参数类型，但返回类型不同，它们被认为是不同的函数，因为函数重载是基于函数签名进行的，而函数签名不包括返回类型。

* 考虑以下示例：

  ```C++
  int foo(int x);
  float foo(int x);
  ```

  * 在这里，我们定义了两个函数名为`foo`，参数类型也相同，但是返回类型不同。
  * 由于函数重载是基于函数签名而不是返回类型进行的，因此这两个函数被认为是不同的函数。
  * 在使用`foo`函数时，编译器将根据所使用的参数类型自动选择正确的函数。
  * 如果你想定义两个函数，它们的名称、参数类型和参数个数都相同，但是返回类型不同，可以使用<font color='red'>**函数模板特化**</font>或者函数重载来实现。
    * <font color='red'>**函数模板特化**</font>[点击跳转到函数模板特化](#函数模板特化)<a id = "返回正文19"></a>
  * 例如：

  ```
  template<typename T>
  T foo(int x);
  
  template<>
  int foo<int>(int x);
  
  template<>
  float foo<float>(int x);
  ```

  * 在这里，我们定义了一个函数模板`foo`，它有一个模板参数`T`和一个整型参数`x`。然后，我们使用函数模板特化定义了`foo<int>`和`foo<float>`两个函数，它们的返回类型分别为`int`和`float`。这样，我们就可以使用`foo<int>(x)`和`foo<float>(x)`来调用相应的函数了。





# <font color='red'>**函数模板特化**</font>

* <a href="#返回正文19">点击返回正文</a>

* **函数模板特化**是指针对某些特定的**模板参数**，提供一个定制化的**函数模板**实现。

  * <font color='red'>**模板参数**</font>[点击跳转到模板参数](#模板参数)<a id = "返回正文20"></a>

* 通常情况下，函数模板可以通过模板参数来推导出函数的参数类型、返回类型等信息，但是在某些情况下，需要针对特定的模板参数提供不同的实现。这时可以使用函数模板特化来解决问题。

  函数模板特化的语法形式如下：

  ```
  arduinoCopy codetemplate <typename T>
  void foo(T arg);
  
  // 对特定类型T进行特化
  template <>
  void foo<int>(int arg) {
      // ...
  }
  
  template <>
  void foo<double>(double arg) {
      // ...
  }
  ```

  在这个例子中，我们定义了一个函数模板`foo`，它接受一个类型为`T`的参数。然后我们对`int`和`double`类型进行了特化，提供了针对这两种类型的定制化实现。特化的语法是，在`template<>`后面跟上函数模板的定义，但是不需要指定模板参数，而是直接在尖括号中给出特化的类型。注意，特化的函数定义必须与原始的函数模板定义相同，包括参数个数和类型、返回值类型等。

  在调用函数模板时，编译器会尝试根据参数类型来推导出使用哪个函数模板。如果能够找到一个与参数类型完全匹配的特化版本，就会使用该版本；否则，就会使用通用的函数模板。

  需要注意的是，函数模板特化只对特定的类型有效，对于其他类型仍然使用通用的函数模板实现。因此，如果需要对所有类型都进行特化，就需要提供一个通用的函数模板实现，或者使用函数重载来实现。



# <font color='red'>**模板参数**</font>

* <a href="#返回正文20">点击返回正文</a>

* 模板参数是指在<font color='red'>**模板定义**</font>中声明的占位符，用于表示模板中需要使用的类型、值或模板。

  * <font color='red'>**模板定义**</font>[点击跳转到模板定义](#模板定义)<a id = "返回正文21"></a>

* 模板参数分为两类：类型参数和非类型参数。

* 类型参数用于表示类型，可以用`typename`或`class`关键字声明，例如：

  ```c++
  template<typename T>
  void swap(T& a, T& b) {
      T temp = a;
      a = b;
      b = temp;
  }
  ```

  * 在这个例子中，`T`是一个类型参数，它用于表示函数`swap`的参数类型。

  * 非类型参数用于表示一个值或一个模板，可以是整数、枚举、指针或引用等，例如：

  ```c++
  template<int N>
  struct Factorial {
      enum { value = N * Factorial<N - 1>::value };
  };
  
  template<>
  struct Factorial<0> {
      enum { value = 1 };
  };
  ```

  * 在这个例子中，`N`是一个非类型参数，它表示一个整数值。
  * `Factorial`是一个递归模板，用于计算阶乘。
  * 当`N`为0时，递归结束，返回1；
  * 否则，递归调用`Factorial<N-1>`计算(N-1)的阶乘，并将结果乘以N。
  * 这是一个使用<font color='red'>**模板特化**</font>实现计算阶乘的例子。它定义了一个模板结构体 `Factorial`，它接受一个整数模板参数 `N`，并在 `enum` 中计算 `N!` 的值。在结构体定义中，我们使用递归方式定义了 `Factorial<N>`，并将其值设置为 `N * Factorial<N - 1>::value`，因此我们可以通过将问题转化为 `Factorial<N - 1>` 来计算 `N!`。这个递归过程一直进行到 `Factorial<0>`，我们在这里进行了模板特化，并将其值设置为1，以结束递归。这个例子演示了如何使用模板和特化来实现通用的算法，并允许在特定情况下使用不同的实现。

* 模板参数可以在模板中使用，用于声明变量、函数、类、结构体等。

* 在模板实例化时，模板参数会被具体的类型、值或模板替换，从而生成具体的代码。









# <font color='red'>**模板定义**</font>

* <a href="#返回正文21">点击返回正文</a>

* 模板定义是指使用模板参数定义一个<font color='red'>**模板**</font>的过程，它可以是函数模板、类模板或别名模板。

  * <font color='red'>**模板**</font>[点击跳转到模板](#模板)<a id = "返回正文22"></a>

* 模板定义使用关键字`template`开始，后面跟着模板参数列表和模板主体，例如：

  函数模板定义：

  ```
  cssCopy codetemplate<typename T>
  T max(T a, T b) {
      return a > b ? a : b;
  }
  ```

  类模板定义：

  ```
  arduinoCopy codetemplate<typename T>
  class MyContainer {
      private:
          T element;
      public:
          MyContainer(T arg) { element = arg; }
          T get() { return element; }
  };
  ```

  别名模板定义：

  ```
  arduinoCopy codetemplate<typename T>
  using MyPair = std::pair<T, T>;
  ```

  在模板定义中，模板参数是使用占位符表示的，例如`typename T`和`class T`表示类型参数，`int N`和`const char* S`表示非类型参数。在实例化模板时，实际的类型或值会替换模板参数，从而生成具体的代码。例如，以下代码会实例化函数模板`max`为`int`类型的版本，并调用该函数：

  ```
  pythonCopy codeint x = 3, y = 5;
  int z = max<int>(x, y); // 实例化为 max(int, int) 并返回 5
  ```

  模板定义允许我们编写通用的代码，可以适用于多种不同的类型或值，从而提高了代码的可重用性和灵活性。



# <font color='red'>**模板**</font>

* <a href="#返回正文22">点击返回正文</a>
* 模板是C++中的一种重要特性，它可以将**代码和数据类型分离**，实现**泛型编程**，从而使代码更加通用、灵活和可重用。**通过使用模板，我们可以编写一次代码，然后用不同的数据类型多次重用它，从而提高了代码的效率和可维护性。**
* 在C++中，**有三种主要类型的模板**：
  * **函数模板**：定义一个通用的函数，可以用不同类型的参数调用它。
  * **类模板**：定义一个通用的类，可以用不同类型的数据成员和成员函数实例化它。
  * **别名模板**：定义一个通用的别名，可以用不同类型的名称替代它。
* 模板使用尖括号`< >`来指定**模板参数**，**模板参数可以是类型、常量或模板本身**。
* 例如，以下代码定义了一个函数模板，用于比较两个值并返回较大的那个：

```c++
template <typename T>
T max(T a, T b) {
    return a > b ? a : b;
}
```

* 在上面的代码中，`typename T`表示类型参数。
* 当调用该函数模板时，编译器会自动根据传递的参数类型推断出模板参数的具体类型。
* 例如，以下代码调用上述函数模板，并将其实例化为`int`类型：

```C++
int a = 3, b = 5;
int c = max(a, b);  // c 等于 5
```

* 需要注意的是，模板的编译发生在实例化的时候，也就是说，只有在实例化时才会检查模板中的语法错误和类型错误。
* 这也就意味着，当我们使用模板时，需要确保模板参数的类型和限制条件都符合要求，以避免编译错误。