# 线程的实现方式多线程模型

* 上个小节中学习了线程相关的一些基本概念、基础知识，这个小节中来看一下有哪几种线程的实现方式，并且会学习几种多线程模型

  

## 知识总览

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305150832825.png" alt="image-20230515083256751" style="zoom:50%;" />

* 线程的实现方式分为用户级线程和内核级线程。 另外还有的系统当中会把这两种实现方式都混合起来使用，这个大家一会会看到实际的例子



## 线程的实现方式

* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305150834512.png" alt="image-20230515083455410" style="zoom: 67%;" />
* 首先看一下第一种线程的实现方式叫做用户级线程。其实这种实现方式是在早期的操作系统，也就是只支持进程，还暂时没有支持线程的那些操作系统当中来使用的。当时的线程是由程序员们写的线程库来实现的，也就是说在这个时代操作系统的视角看到的，其实依然是只有进程。但是，程序员们写的这些应用程序当中，可以使用线程库来实现多个线程并发的运行这样的事情。 
* 还是结合上一小节当中提到的例子来进行理解，上个小节中提到过QQ可以一边视频聊
  天，一边文字聊天，一边 实现文件传输，上个小节中提出了这样的方案，如果要让这三个事情并发的运行的话，那么在不支持线程的系统当中，我们可以分别建立三个进程，这三个进程分别是处理其中的某一个事情，进程1的代码是不断的来处理视频聊天这个事情，进
  程2是不断的来处理文字聊天，进程3是处理文件传输，可以看到处理视频聊天的代码是用这个循环来一遍一遍地不断的执行的。另外的两个代码也一样

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305150841296.png" alt="image-20230515084124206" style="zoom: 67%;" />

* 所以其实可以用这样的方式来实现，让这三段代码并发的运行，我们用一个while循环让它一直不断的循环，然后`i`的值会。 012012
  这样循环的变化， 当`i=0`的时候可以让这个进程来处理视频聊天。 当`i=1`的时候让他处理文字聊天，当`i=2`的时候让他处理文件传输，由于程序进行while循环的速度是非常快的。其实也可以把这三段代码看作是三段并发运行的代码，它们分别处理了不同的事情。 
* 所以其实如果从单纯代码的角度来看的话，那么一个线程，其实可以把它理解为是一段代码逻辑。 这个地方提到的这三段代码逻辑，就可以把它看作是三个线程，另外我们这写的while循环的处理逻辑，其实就可以把它看成一个最简陋最弱智的一个线程库。 这个线程库完成了对各个线程的管理调度的工作，这个弱智线程库对这些线程的调度规则很简单。 就是第一次先处理视频，第二次处理文字，第三次处理文件， 第四次又处理视频，第五次
  处理文字等等等。 这个地方我们用一个简单的while循环和几个if语句就实现了一个最简单最简单的线程库。

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305150847886.png" alt="image-20230515084711810" style="zoom: 67%;" />

* 很多的编程语言都会提供用于管理线程的线程库，不过他们提供的线程库要比我们的while循环复杂多了，程序员可以利用线程库来实现用户级线程的创建，销毁，调度等等一系列的功能，接下来问题来了，在刚才所说的这个例子当中。 操作系统其实只看得到进程，而这个进程上处理机运行的时候，其实是程序员自己写了一个线程库来创建了逻辑上的线程。 也就是这儿的用户级线程

* 那我们来思考这样的几个问题，第一，这些用户级线程的管理工作是由谁来完成的？其实刚才写的while循环就是简单的实现了对这三个线程的管理，让他们交替的运行。 所以用户级线程的管理工作是由应用程序通过线程库来完成的，并不是操作系统负责的。 

* 第二个问题，线程切换是否需要CPU从用户态转换为内核态？经过刚才的分析，这个问题其实也不难回答，线程切换其实是由while循环来控制的，这并不需要涉及到请求操作系统服务之类的事情。 所以线程切换的管理是由线程库应用程序自己完成的，在用户态下就可以完成线程的切换工作，并不需要操作系统的干涉。

* 第三个问题，操作系统是否能意识到用户级线程的存在，显然操作系统只能看到进程的存在。 只知道这个进程，它是一坨代码，而在这坨代码里边又分别被分为了几个线程， 操作系统是意识不到这些线程的存在的。 所以
  这也是为什么这种线程的实现方式， 叫做用户级线程的原因，只有用户才能感知到用户级线程的存在。 而操作系统其实感知不到这些用户级线程的存在

* 最后要思考的问题是，这种实现方式有什么优点和缺点呢？

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305150853764.png" alt="image-20230515085331614" style="zoom: 67%;" />

* 首先来看优点。 刚才提到过用户级线程的管理工作，包括切换， 创建等等这些工作都不需要请求操作系统的服务，只需要在用户态下就可以完成。也就是说对用户级线程的管理并不需要涉及到CPU变态这个事情，而之前我们说过CPU变态是有开销，有成本的。 所以那既然用户级线程的管理工作不需要CPU切换到内核态，所以对于他们的管理工作肯定开销是比较小，效率是比较高的。接下来看一下用户级线程这种实现方式有什么缺点？

* 我们回到自己实现的这三个最简单的用户级线程

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305150856567.png" alt="image-20230515085644448" style="zoom:67%;" />

* 假设此时这个进程上处理器运行，而这次运行的时候i的值是等于零的。 也就是说，视频聊天的这一段代码会上处理机运行，但是假设视频聊天的这段代码在运行的过程中发生了阻塞。 比如说他想要申请摄像头那个资源， 但是申请失败， 那么由于他想要的这个系统资源得不到满足， 因此这段代码的执行就会被阻塞。 想一下，既然这个代码的执行被阻塞在了这个地方，那么这个while循环还能继续下去吗？肯定不行了。只有这个阻塞被解除之后，这个while循环才可以继续执行下去。 所以，这种用户级线程的实现方式有一个很明显的缺点，那就是如果其中的某一个线程被阻塞那么其他的这些线程也会被阻塞，也没办法执行下去，那从这段伪代码当中相信不难理解这一点，所以这就是用户级线程这种实现方式最大的一个缺点，只要其中一个被阻塞，整个进程都会被阻塞，所以这种方式的并发度并不高。

* 另外， 虽然上个小节中提到过引入线程之后，线程成为了CPU调度的基本单位，但是如果这个线程是用用户级线程这样的方式来实现的话，那么在这种情况下，其实CPU的调度单位依然是进程，操作系统是给进程分配CPU时间的， 因此即便我们的电脑是多核处理机。 但是由于进程才是CPU调度的基本单位， 因此这个进程只能被分配一个核心，所以这些线程并不能并行的运行，这是早期的操作系统当中人们实现线程的方式在这个阶段操作系统还只支持进程，并不支持线程。 

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305150902775.png" alt="image-20230515090224641" style="zoom:67%;" />

* 之后，随着操作系统的发展越来越多的操作系统开始支持线程，操作系统支持的这种线程就叫做内核级的线程。 这种内核级线程就是操作系统视角也可以看得到的线程，现在的操作系统大多都支持内核级线程，比如说很熟悉的Windows、Linux等等。接下来我还是要思考同样的三个问题，在引入了内核级线程之后，这个线程的管理工作到底是谁来做呢？由于内核级线程是在操作系统层面实现的线程，因此内核级线程的管理工作当然是需要由操作系统来完成。第二个问题，线程的切换是否需要CPU状态的转换？既然内核级线程由操作系统负责管理，他们的切换，他们的管理工作肯定是需要操作系统介入的。 因此，在进行线程切换的时候， 当然是需要从用户态转变为内核态。 第三个问题。 操作系统是否能够意识到内核级线程的存在，这个不用说了

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305150906616.png" alt="image-20230515090616511" style="zoom:67%;" />

* 最后根据刚才认知到的这些信息来分析下这种实现方式有什么优点和缺点。 首先来看优点。如果某一个操作系统支持内核级线程的话，那么在这种操作系统当中， 内核级线程是处理机调度的基本单位。而进程只作为分配资源的基本单位， 因此在多核CPU的环境下，这几个线程可以分别分派到不同的核心下并行的执行。 另外不同的内核级线程中可以跑不同的代码逻辑，比如说这个代码逻辑是实现视频聊天，这个是实现文字聊天，这个是实现文件传输。 那么，由于内核级线程是处理及分配的基本单位。在这种情况下，即便其中的某一个线程被阻塞，其他的两个线程依然可以继续执行下去。 所以采用这种方式有一个优点，那就是线程之间的并发能力强，

* 再来看一下这种方式的缺点。 当引入了内核级线程之后，那一个进程有可能会对应多个
  内核级线程，操作系统需要对这些线程进行管
  理。 所以内核级线程之间的切换是需要CPU从用户态变为内核态的，当切换完成之后，还需要从内核态再转回用户态。 而之前我们提到过很多次CPU,变态是有成本，有开销的，所以这种实现方式会导致线程的管理成本要更高，开销更大。 刚才学习了用户级线程和内核级线程，这两种线程的实现方式，这两种方式都有各自的优点和缺点

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305150911092.png" alt="image-20230515091120977" style="zoom: 67%;" />

* 有没有可能把这两种方式结合起来呢？在支持内核级线程的系统当中，如果再引入线程库的话，那么我们就可以实现把若干个用户级线程映射到某一个内核级线程这样的事情。 根据用户级线程和内核级线程的这种映射关系就引出了三种多线程模型。 像刚才一直在讲的这种模型，一个用户级线程对应一个内核级线程，这个是一对一模型。 如果采用这种映射方式的话，一个进程有多少个用户级线程就会有多少个内核级线程， 它们都是——对应的。 这种方式的优点就是刚才提到过的一个线程被阻塞之后，别的线程还可以继续执行， 因为内核级线程是处理机分配的基本单位。 

* 另外，这些代码逻辑，这些线程可以分派到多核处理机上并行的执行， 这是它的优点，而缺点和刚才所说的一样，就是管理的成本高，开销大， 因为线程的管理工作肯定需要切换到内核态，只要涉及到CPU变态，就会使开销变大。 

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305150916881.png" alt="image-20230515091625763" style="zoom:67%;" />

* 再来看第二种多线程模型， 叫做多对一，也就是多个用户级线程映射到一个内核级线程。 如果是这种映射关系的话， 其实它就退化成
  了之前提到的纯粹的用户级线程那种实现方式。由于一个进程只被分配到了一个内核级线程，而在这个内核级线程上面， 通过线程库又实现了三个用户级线程。 因此，这些线程的管理工作只需要在用户态下就可以完成，
  所以线程的管理开销小，效率高

* 但是缺点就是其中的一个用户级线程阻塞之后会导致其他的用户级线程也跟着被阻塞，并发性不高，并且这些用户级线程是不可能并行的运行的。 因为只有内核级线程才是处理机的分配单位，如果一个进程只对应一个内核级线程的话，那么在同一时刻，这个进程肯定只能被分配一个CPU的核心。 当然，如果给这个进程分配多个内核级线程的话，那么在多核CPU环境下，这些内核级线程肯定是可以并行的运行的。不过，在考试当中， 如果提到这种多对一的线程模型的话，那么默认一个进程只被分配了一个内核级线程。 

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305150920165.png" alt="image-20230515092030052" style="zoom:67%;" />

* 最后要认识的是多对多模型就是把n个用户级线程映射到m个内核级线程上n的数量要大于等于m。在这个模型当中，由于一个进程有两个内核级线程， 因此其中一个内核级线程被阻塞的话，另一个内核级线程是可以继续运行下去的。 因此，它克服了多对一模型并发度不高的缺点。 另一方面，这种多对多的模型n是大于等于m的，也就是说内核级线程的数量要比用户级线程的数量要更小。

* 因此，操作系统对这些线程的管理开销也相应的会更小。 而在一对一模型当中，有多少个用户级线程就需要给它创建多少个对应的内核级线程。 内核级线程太多的话， 操作系统的管理开销就会更大，所以这种方式它又克服了一对一模型当中线程管理开销太大的缺点。 

* 再来总结一下用户级线程和内核级线程的区别和联系，可以这么来理解。 所谓用户级线程可以把它理解为是代码逻辑的载体，比如说这个用户级线程。 它承载的是文字聊天相关的代码逻辑，这个用户级线程承载的是文件传输相关的代码逻辑。 而内核级线程可以理解为是运行机会的一个载体， 因为操作系统在分配处理机CPU资源的时候。 是以内核级线程为单位进行分配的，所以在这边这个模型当中，虽然有三个内核级线程，但是这个进程最多只可能被分配两个CPU的核心。

* 一段代码逻辑只有获得了运行机会的时候，它才可以被CPU执行，这可以让线程管理有更多的灵活性。比如说在这边这个例子当中，如果QQ视频聊天需要耗费比较多的CPU资源的话，那么可以让左边这个内核级线程，让他专门来执行视频聊天相关的代码逻辑，而右边这个内核级线程可以让他并发的执行文件传输和文字聊天这两个部分的逻辑，如果某一个时刻文件传输又要耗费很多的CPU资源的话，那么可以把文字聊天这一块的逻辑把它映射到这边，让这个内核级线程来进行处理。 

* 需要注意的是，在引入了内核级线程之后，一个进程可能会对应多个内核级线程，而只有所有的内核级线程都被阻塞的时候，才说这个进程进入了阻塞状态。 

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305150928812.png" alt="image-20230515092853672" style="zoom:67%;" />

* 在学完了数据结构，有了一些这写代码的思想之后，再回来理解这个部分的内容，可能也会更容易一些
* 需要再次强调的是用户级线程是在用户视角能看到的线程， 由线程库实现。 就像那个很简单粗暴的while循环可以认为是一个最简单
  的线程库，内核级线程才是操作系统视角能看得到的线程，由操作系统来负责管理。 所以内核级线程才是处理机分配的单位
* 对于介绍这几种多线程模型来说，主要是要理解它们各自的优缺点。另外，这个部分的内容比较容易考察关于阻塞的问题，这个大家在课后习题当中会有体会。