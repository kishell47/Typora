# 进程控制

* 在这个小节中会学习进程控制相关的知识点



## 什么是进程控制？

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111659151.png" alt="image-20230511165903007" style="zoom: 50%;" />

* 什么是进程控制呢？王道书上给出了一些描述，进程控制的主要功能是对系统当中的所有进程实施有效的管理，具有创建新进程， 撤销已有进程，实现进程状态转换等功能。
* 其实说白了进程控制就是要实现进程的状态转换。 比如说创建一个新进程，就是让一个进程从无到有到创建态，再到就绪态，这是创建新进程所需要干的事情。 
* 撤销一个已有进程，就是让进程进入终止态，最终把这个进程干掉的过程，所以其实所谓的进程控制就是要实现这些进程的状态转换，在进程的状态转换的时候，操作系统需要做一些什么事情呢？这就是这个小节当中要讨论的内容



## 知识总览

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111703407.png" alt="image-20230511170342266" style="zoom:50%;" />

* 刚才简要地了解了什么是进程控制，接下来会介绍怎么实现进程控制，需要用原语来实现，这个一会儿会展开
* 之后会介绍几个进程控制相关的原语， 它们分别需要实现哪些功能，接下来要探讨的问题是怎么实现进程控制？



## 如何实现进程控制？

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111705942.png" alt="image-20230511170536837" style="zoom: 50%;" />

* 刚才提到进程控制也就是进程的状态转换相应的处理是需要用原语来实现的。 而原语这个概念，在第一章当中提到过
* 操作系统的内核中有一些特殊的程序，它叫原语。 原语这种程序它的执行是具有原子性的，也就是说这个程序运行是必须一气呵成的，中间不可以被中断。也就是说实现进程的状态转换这个事情，中间的一系列操作必须一气呵成。
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111708659.png" alt="image-20230511170809480" style="zoom:50%;" />
* 接下来考虑一下这样的问题，为什么进程控制或者说进程的状态转换这个过程需要一气呵成，结合上一小节当中学习到的知识，知道在PCB当中会有一个变量，用来表示进程当前所处的状态，比如说这个state变量当它为1的时候，认为它是在就绪态，当它为二的时候在阻塞态。如果一个进程，处于就绪态state=1的话，这个进程的PCB肯定是需要挂在就绪队列里的。
* 而如果state=2的话，那么这个进程的PCB就应该被挂在阻塞队列里，接下来考虑这样一个事情。 处于阻塞队列的这些进程肯定是在等待某种事件的发生。 假设现在这个进程二，也就是PCB 2所对应的进程所等待的事件已经发生了，那么在这种情况下，这个进程应该从阻塞态转换为就绪态，所以操作系统当中的内核程序就需要把这个进程的状态从阻塞态变为就绪态。进行状态转换的这个过程至少需要做两件事情，第一件事要PCB当中的state变量从二变为一。 第二件事还需要把这些PCB2从阻塞队列当中摘出去，然后挂到就绪队列当中。所以操作系统在让进程的状态发生转换的过程当中至少需要干两件事
* 接下来考虑假设现在state 1已经被它设为了一。 而在完成了这一步之后，突然又检测到了一个中断信号，那么既然检查到了中断信号，系统肯定需要对这个中断进行处理。而在这个时候，PCB当中state=1，也就是说从state这个变量来看这个进程的状态是就绪态。 
* 但是从它所处的队列来看，这个PCB 2此时又还是在阻塞队列当中。 所以这就导致了PCB 2当中的这个变量所表示的状态和PCB 2它所处的这个队列这两个信息对不上了
* 所以说如果操作系统让进程的状态转换的中间处理的步骤不能一气呵成的话就有可能会出现某些关键的数据结构信息不统一的情况，这些数据结构是非常重要的， 这有可能会影响到操作系统进行后续的别的一些工作，可能会让系统出错，所以应该就可以明白为什么进程的状态转换， 或者说进程控制的过程需要一气呵成了
*  刚好原语这种特殊的内核程序，它具有一气呵成，不可被中断的性质。 所以我们可以用原语这种特殊的程序来实现一气呵成这样的事情。

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111721727.png" alt="image-20230511172135626" style="zoom: 50%;" />

* 接下来要探讨的问题是为什么原语这种特殊的程序可以一气呵成，不被中断呢？
* 其实它的这种原子性是用两个特权指令关中断和开中断这两个指令来实现的。 看一下这两个指令的作用，假设这是一个正在运行的内核程序，CPU会依次执行这些指令。
* 并且根据第一章的讲解知道CPU每执行完一条指令之后，它都会例行的检查是否有中断信号需要处理。 如果说他在执行了指令二之后CPU发现此时有一个中断信号，在这种情况下CPU就会暂停执行当前的这个程序，转而执行一个处理中断的程序，等这个中断处理完成之后，才会再回到原来这个程序继续往下执行。 这是之前认识到的情况，就是CPU每执行完一条指令，它都会检查是否有外部中断信号需要处理。

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111725431.png" alt="image-20230511172503294" style="zoom:50%;" />

* 接下来再来看一下，如果执行了关中断指令，会发生什么情况？假设此时CPU正在依次的执行这些指令，然后当他执行了关中断这条特权指令之后CPU就不再例行检查中断信号了，所以接下来CPU会继续往下执行，如果说此时它执行指令a的这个过程当中，有一个外部中断信号到来了。 但是此时它并不会像之前一样例行的检查是否有中断信号，而是会继续往下处理一直到CPU执行了开中断指令之后，它才会恢复以前的那种习惯，也就是每执行完一条指令，就会检查一下此时是否有外部中断信号需要处理，所以当它执行了开中断指令之后，它会发现之前有一个中断信号还没有处理，所以在这个时候CPU才会着转向执行中断处理程序。 
* 所以从刚才这个例子当中就可以看到，在关中断和开中断这两条指令中间的这一系列的指令序列，它们的执行肯定是不可被中断的，这样的话就实现了开篇提到的所谓的原子性。 这段指令序列的执行肯定是一气呵成的，它中间不可能再被中断，所以这是关中断指令和开中断指令的特殊的作用
* 显然这两个指令它们肯定是特权指令，接下来我们来思考一个问题。如果这两个特权指令允许普通的用户程序使用的话会发生什么情况呢？ 是不是就意味着可以在程序开头就植入一个关中断指令，然后一直到我的程序末尾才再执行开中断指令，这样的话，只要我的程序上CPU运行了，那我的程序肯定会一直霸占CPU而不会被中断。 显然，这种情况是不应该让它发生的。 所以关中断指令和开中断指令，它们是特权指令，只能让内核程序使用，而不能让普通的用户程序使用。
* 总的来说，第一进程控制或者说进程的状态转换这个事情必须一气呵成。而想要做到一气呵成可以用原语这种特殊的程序来实现，而原语的实现需要由开中断指令和关中断指令来配合着完成

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111736257.png" alt="image-20230511173627101" style="zoom: 67%;" />

* 接下来要讨论的问题是进程控制相关的这些原语，或者说相关的这些特殊的程序。他们在背后需要完成一些什么事情呢？
* 首先看第一个原语，这个原语是用于实现进程的创建的。 如果操作系统要创建一个进程，那么它就必须使用创建原语。 创建原语，首先是要申请一个空白的PCB，因为PCB是进程存在的唯一标志，所以要创建一个进程，当然需要创建一个和它相对应的PCB，另外还会给这个进程分配它所需要的资源，比如说像内存空间等等，然后还会把PCB的内容进行一些初始化的工作，比如说分配PID、设置UID等等。 
* 最后还会把PCB插入到就绪队列，所以说创建原语让一个进程从创建态进入到了就绪态，把它放到了就绪队列里。 有一些比较典型的事件会引起操作系统使用创建原语， 创建一个进程，比如说当一个用户登录的时候，操作系统会给这个用户建立一个与它对应的用户管理进程或者用户通信进程等等或者发生作业调度的时候，也会创建一个进程。 
* 作业就是此时还放在外存里的那些还没有投入运行的程序，作业调度就是指从外存当中挑选一个程序，把它放入内存，让它开始运行。 当一个程序要开始运行的时候，肯定需要创建和它相对应的进程的， 所以当发生作业调度的时候， 就需要使用到创建原语。

* 另外，有的时候一个进程可能向操作系统提出某些请求，然后操作系统会专门建立一个进程来处理这个请求。还有的时候，一个进程也可以主动的请求创建一个子进程。 总之，发生这些事件的时候都会引起系统创建一个新的进程。 也就是说，它会使用到这个创建原语。 

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305112056332.png" alt="image-20230511205653148" style="zoom: 50%;" />

* 接下来要看的是撤销原语， 撤销原语是要终止一个进程的时候使用的，使用了撤销原语之后，就可以让一个进程从某一种状态转向终止态，最终这个进程从系统中彻底消失。 撤销原语需要做这样的一些事情， 首先既然要撤销一个进程，肯定需要找到这个进程相应的PCB。 如果说这个进程此时正在运行的话，就需要立即剥夺它的CPU使用权，然后把CPU分配给其他进程。 同时，操作系统在杀死一个进程的时候，还会杀死所有它的子进程。 并且这个进程被撤销之后，他之前所占有的那些资源应该归还给他的父进程。 最后的最后，还需要把这个进程的PCB从系统中删除，那这样的话，这个进程就彻底的完蛋了。
* 有的同学可能不理解， 子进程， 父进程这样的概念，来看一个很实际的例子，这是我现在正在录视频的时候使用的电脑，这个界面显示的是此时我的电脑当中正在运行的各种进程，这个界面中的这种显示方式其实就反映了这些进程之间的父子关系。 

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305112101670.png" alt="image-20230511210139451" style="zoom: 67%;" />

* 可以看到，这有一个PID为零的进程，它是最祖先的一个祖先进程，然后这个祖先进程，他创建了一个PID为1的进程，这个进程叫做launched。它就是在第三章会学习到的所谓的装入程序，或者叫装入进程，在开机了之后，启动的所有的别的那些进程其实都是这个装入进程来启动的，所以别的那些进程都是这个装入进程的子进程。
* 除了他之外，其他的那些进程也可以创建自己的子进程来完成相应的一系列工作， 比如说访达这个进程就创建了这几个它自己的子进程。

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305112105798.png" alt="image-20230511210526509" style="zoom: 67%;" />

* 这样的设计方法有什么优点呢？可以想一下，刚开始系统中几乎所有的资源都是这个进程所拥有的比如说我的电脑里8 GB的内存全部是他所拥有的，之后当他在建立自己的这些子进程的时候，他可以按照这些子进程的需要，把自己手里的那些资源再分配给他手底下的这些进程，比如说他本来手里有8 GB的内存，那他把其中的50兆字节分配给了这个进程。 把54.5M字节分配给了这个进程。而当他的这些子进程终止了之后，需要把自己手里的这些资源还给他们的父进程，也就是上面的这个进程。 
* 所以其实操作系统当中的各个进程，它们之间的关系是一种树形的结构。 系统中的零号进程和一号进程是最祖先的两个进程，然后这两个进程又一次创建了他们的子进程，各个进程又可以再创建各自的子进程。 所以这些进程之间的关系其实是一种树形的结构，不过这个并不是操作系统这一门课要考察的重点，只是为了让大家能够更深入的理解这提到的这两个特性。 
* 很多事件有可能会引起一个进程的终止。 比如说一个进程自己请求终止，也就是它使用了exit这个系统调用。这种情况下操作系统在背后就会需要使用到这个撤销原语来把这个进程撤销掉。 另外, 如果一个进程做了一些非法的事件，比如说整数除以零或者非法使用特权指令，这种情况也会被操作系统强行的撤销，强行把它干掉。 还有一种情况，有时候是用户会选择杀掉一个进程，比如说我们在使用Windows电脑的时候，经常出现卡死的情况，这种情况下，很多同学喜欢用Ctrl+Alt+delete打开任务管理器，然后结束掉了某一个卡死的进程，这种就是外界干预的情况。

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305112127887.png" alt="image-20230511212732663" style="zoom: 67%;" />

* 接下来要看的是阻塞原语和唤醒原语，这些原语到底要干什么这些事情并不需要死记硬背，只需要理解它背后的过程就可以，考试的时候不可能让你默写这些东西的。 所以我们着重以理解为主，大家不需要刻意的记忆。 
* 有的时候一个进程可能会从运行态进入到阻塞态，在这种情况下操作系统就会在背后执行一个阻塞原语来实现状态的转换，阻塞一个进程需要做的事情比较简单，首先是找到这个进程对应的PCB，然后需要保护进程运行的现场。什么叫保护进程运行的现场，这个我们一会儿再解释。 这又是一个比较庞大的话题，另外系统还需要把PCB当中的状态信息设置为阻塞态。然后让这个进程下处理机并且把它插入到相应的等待队列当中。 经过上个小节的学习我们知道一个进程需要被阻塞，肯定是因为它主动请求要等待某一个事件的发生。 而如果这个进程它所等待的事件发生了之后，这个进程就会被唤醒，也就是说操作系统会让这个进程的状态从阻塞态又回到就绪态。在这个时候就会需要使用到唤醒原语， 唤醒原语需要做这样的几个事情，首先要找到它的PCB，然后把PCB从等待队列当中移除，然后把它设置为就绪态，并且把PCB插入到就绪队列当中等待被调度
* 需要注意的是一个进程因为什么事情被阻塞就应该被什么事情给唤醒。 所以唤醒原语和阻塞原语，它们必须是成对使用的

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305112128776.png" alt="image-20230511212836620" style="zoom: 50%;" />

* 接下来再来认识最后一个原语， 叫做切换原语。切换原语，会让此时正在处于运行态的进程下处理机，让它回到就绪队列，并且从就绪队列当中选择一个处于就绪态的进程，让它上处理机运行。 所以切换原语会让两个进程的状态发生改变，切换原语需要做这样的一些事情。首先是需要把进程的运行环境信息存到PCB当中。什么叫进程的运行环境信息呢？ 这点涉及到一些硬件的知识，我们一会儿再展开细聊。 另外还会把进程的PCB移到相应的队列，比如说让下处理机的进程的PCB回到就绪队列当中。 另外还会挑选一个进程，让他上处理机运行，并且更新他的PCB的内容。 同时，它还会从这个进程的PCB当中恢复这个进程所需要的运行环境。那什么叫保存运行环境？ 什么叫恢复运行环境？这是比较难理解的地方。 接下来得深入探讨一下这个问题。

 <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305112136080.png" alt="image-20230511213623971" style="zoom:50%;" />

* 在之前的学习中认识到了一个程序的运行需要经历这样一系列的流程，程序运行之前需要把它相应的这些指令放入到内存当中。 然后CPU从内存中读取这些一条一条的指令并且执行，但是接下来要拓展一个更深层的细节。 CPU在执行这些指令的过程中，需要进行一系列的运算，CPU当中会设置很多的寄存器来存放这些指令，这些程序在运行过程当中所需要的某些数据，总之寄存器就是CPU里边用于存放数据的一些地方。 

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305112147386.png" alt="image-20230511214710264" style="zoom: 50%;" />

* CPU当中会有各种各样的寄存器，比如说之前提到过PSW就是程序状态字寄存器。 CPU的状态内核态还是用户态，这个状态信息就是保存在PSW这个寄存器当中的。 当然，除了CPU状态信息之外，PSW中还会保存别的一些信息，这儿就不展开，这是计算机组成原理里边需要学习的地方。 

* 另外CPU中还会有一个比较关键的寄存器叫做PC，也就是程序计数器寄存器。 这个寄存器里边存放的是接下来需要执行的指令的地址是多少，这一点—会结合实例就很好理解了。 

* 另外CPU当中还会有一个指令寄存器，这个寄存器当中存放的是当前CPU正在执行的那条指令。CPU中还会有一些其他的通用的寄存器可以用来存放一些别的必要的信息等等等，总之CPU当中会有一系列的寄存器。 这儿只列举了几个操作系统这门课当中大家需要稍微的了解一下的寄存器。 接下来来分析一下这样的一些指令序列的执行， 在背后发生了什么样的事情？这自己胡乱写了四条指令，这四条指令所完成的事情就是定义了一个叫做x的变量，并且实现了x++的操作。 假设此时CPU正在执行的是指令一，那么它会把指令—的内容读到IR，也就是指令寄存器当中。 并且程序计数器这个寄存器当中会存放接下来它应该执行的那一条指令，也就是指令二的地址。 此时CPU执行指令一，它发现指令一是让它往内存的某一个地方写入一个变量x的值。 CPU执行指令一的时候就会往内存的某一个地方写入变量x的这个值也就是一。执行完指令一之后CPU就会开始执行下一条指令，而从PC这个寄存器当中，它就知道下一条要执行的指令应该是指令二。所以接下来它会取出指令二，把指令二的内容放在IR，也就是指令寄存器当中，同时PC的内容也更新为再下一条指令。

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305112155615.png" alt="image-20230511215531473" style="zoom: 50%;" />

* 指令二是让CPU把变量x的值放到某一个通用寄存器当中，所以CPU会从内存中取出这个x变量的值把它放到通用寄存器当中。 于是这个寄存器的内容就变成了一，这样的话就执行完了指令二，再接下来CPU又要执行再下一条指令，所以它会取出指令三。

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305112156356.png" alt="image-20230511215648197" style="zoom:50%;" />

*  然后PC的内容同样的也会更新，指令三是让他把寄存器当中的数据进行加—的操作。 所以这个通用寄存器中的值就会从一变成二，再接下来CPU又会执行再下一条指令

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305112201319.png" alt="image-20230511220120194" style="zoom:50%;" />

* 那么此时执行的这一条指令指令四是让他把这个通用寄存器当中的内容把它写回到变量x所存放的这个位置当中。所以执行了指令四之后，就会把内存当中x的值从一变成了二。 

* 所以可以看到执行x++这样的操作，其实在背后CPU是执行了一系列的更基本的指令才完成了这个事情。 并且从刚才讲的这个过程当中，会发现这些指令顺序执行的过程当中有很多中间结果是放在这些寄存器当中的。比如说x++这个操作刚开始其实只是把它放在了通用寄存器里， 而并没有写回内存。 但是需要注意的是，这些寄存器并不是这个进程所独属的，如果其他进程上CPU运行的话，那么这些寄存器也会被其他进程所使用。

* 这会发生什么情况呢？ 我们再把这个故事从头捋一遍

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121552028.png" alt="image-20230512155204914" style="zoom: 67%;" />

* 现在这个CPU要依次的执行这些指令，那刚开始执行指令一。

* 指令二

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121553212.png" alt="image-20230512155330123" style="zoom:50%;" />

* 指令三

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121554184.png" alt="image-20230512155421090" style="zoom:50%;" />

* 当它执行了指令三之后，寄存器里的这个值变成了二。而此时， 如果说他要转向执行另一个进程，会发生什么情况呢？刚才说到，如果另一个进程上CPU运行的话，那么另一个进程也会使用到这些寄存器，所以另一个进程在上CPU运行的时候，有可能会把前一个进程在寄存器当中保留的这些中间结果覆盖掉，比如说它覆盖成了这个鬼样子。 

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121558393.png" alt="image-20230512155811315" style="zoom:50%;" />

* 之前的进程执行到了指令三，因为它的前三条指令执行的那些中间结果都已经被覆盖了。 所以这个进程已经没有办法再往下执行了，所以为了解决这个问题，可以采取这样的策略。 
* 当一个进程要下处理机的时候，可以把它之前运行的这个运行环境的信息把它保存在自己的PCB当中。 
* 当然，这个PCB当中并不需要把所有的寄存器信息都保存下来，只需要保存一些必要的信息就可以了。 比如说PSW PC还有这个通用寄存器。这个进程执行了前三条指令之后，它的运行环境是这个样子的

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121600522.png" alt="image-20230512160038436" style="zoom:50%;" />

* 把它放到了PCB当中，接下来才可以切换成别的进程，接下来别的进程在使用CPU的时候可能会往这些寄存器当中写各种各样的数据，总之之前那个进程的数据有可能会被覆盖。

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121602261.png" alt="image-20230512160209176" style="zoom:50%;" />

* 但是当之前的这个进程需要重新回到CPU运行的时候，操作系统就可以根据之前保存下来的这些信息来恢复它的运行环境了。 把它的运行环境恢复之后CPU就知道接下来它要执行的是指令四。

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121604501.png" alt="image-20230512160421398" style="zoom:50%;" />

*  并且此时通用寄存器当中存放的数值是二。 所以既然接下来要执行的是指令四，CPU就会根据PC的这个指向，把指令四的内容取到IR这个寄存器当中，然后让PC指向下一条指令。 同时CPU开始解析这条指令到底是要干什么，发现指令四是让他把寄存器当中的内容写回到x存放的位置。 所以接下来他就可以把二这个内容写回到x的这个位置，于是x++这个操作就真正的被完成了。

* 总之，这个地方讲了这么多的内容，想让大家知道的就是什么叫做进程的运行环境

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121609105.png" alt="image-20230512160902990" style="zoom:50%;" />

* 运行环境或者说进程上下文就是进程在运行过程当中，寄存器里存储的那些中间结果。当一个进程需要下处理机的时候，需要把它的这个运行环境存到自己的PCB当中。而当一个进程需要重新回到CPU运行的时候，就可以从PCB当中恢复它之前的这个运行环境，让它继续往下执行了。所以保存进程的运行环境和恢复进程的运行环境，这是实现进程并发执行的一个很关键的一个技术。 

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121612263.png" alt="image-20230512161215141" style="zoom: 67%;" />

* 这一小节讲了一些涉及底层硬件的一些知识，可能学过计组的同学觉得这些其实都很好理解
* 在操作系统这门课当中，硬件相关的知识不需要深究，只是为了让大家理解其中的某一些很关键的操作系统概念不得不提一些硬件的知识，毕竟操作系统是最接近硬件的一层软件，
* 大家需要注意一下原语这个概念， 它使用关中断和开中断来实现，它的执行必须一气呵成，不可中断。
* 之后介绍了一些进程控制相关的原语，各个原语中间做了各自的事情，但是这些都不需要死记硬背。 其实，无论是哪一个控制原语，它所要做的无非就是这么三件事，第一就是更新PCB当中的一些信息，第二是把PCB插入到合适的队列。第三，向进程创建和进程终止的时候，有可能还需要分配和回收这个进程的资源。 更新PCB的信息，主要是修改这个进程的状态，也就是state那个变量。 或者就是往PCB当中保存进程的运行环境，或者从PCB恢复进程的运行环境。
* 总之，了解了这些控制原语背后做的事情，能够帮助我们更好的理解进程管理，处理机管理这一系列的知识。 但是这些内容确实不需要死记硬背，所以虽然这个小节看起来内容很多，但是更多的都是理解性的东西， 大家不需要花时间去记忆。 希望大家不要惊慌