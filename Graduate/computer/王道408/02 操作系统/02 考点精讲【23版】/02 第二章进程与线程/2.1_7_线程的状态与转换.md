# 线程的状态与转换



## 知识总览

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305160852173.png" alt="image-20230516085216066" style="zoom: 50%;" />

* 线程的状态与转换和进程的状态与转换几乎是一模一样的。 

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305160855458.png" alt="image-20230516085525352" style="zoom:50%;" />

* 并且线程的状态通常只关注最核心最主要的三个状态，也就是运行态，就绪态和阻塞态。 它们之间的转换和进程之间的转换完全一致。 

* 如果一个系统支持线程的话，那么一个运行态的线程，它被分配的时间用完了，那么它就会下处理机。 进入就绪态，而一个就绪态的线程，如果它被调度程序选中，那么就可以从就绪态回到运行态上处理机运行。而一个正在运行的线程， 如果它发出了某种请求，等待某个事件的发生，比如说等待IO完成，那么它
  就会从运行态转变为阻塞态。 而如果一个阻塞的线程， 它等待的事件发生了，那么它就会从阻塞态回到就绪态

* 所以这就是线程的状态与转换。着重关注三状态的模型

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305160858322.png" alt="image-20230516085846227" style="zoom: 67%;" />

* 接下来线程的组织与控制，其实线程的组织与控制和进程的组织与控制也是非常类似的。 

* 在组织与控制进程的时候，操作系统会对进程的PCB，也就是进程控制块进行管理，其中包含了进程的各种各样的信息，对于线程来说，要管理线程，首先得给各个线程建立一个与之对应的数据结构，线程对应的数据结构就是TCB，也就是线程控制块。 每个线程控制块里边会包含这样的一些内容，可以简称为
  TID，这和进程的PID是很类似的。

* 其次，每一个线程执行的代码可能是各不相
  同的，因此每个线程，它执行到代码的哪个位置，得把它记录下来，所以TCB当中还会包含程序计数器PC，用于指明线程， 现在执行到哪了？如果一个线程切换下处理机，此时就需要把处理机上的 PC的值保存到TCB当中

* 这个线程的运行现场运行环境得被恢复，就可以从这个TCB当中取出PC的值，把它放回PC
  寄存器里边。 这是属于线程运行现场的信息，除了程序计数器PC之外，还需要保留其他的通用寄存器。 学过计组都知道代码运行的中间结果会被保存到各种各样的寄存器里边，因此当我们切换线程的时候也需要保存现成的各种寄存器的值，除了寄存器之外，还有一个重要的信息叫做堆栈。堆栈是用于保存函数调用的信息A调用了B，B调用了C，并且会记录每一次的函数调用它的返回地址是什
  么？ A调用了B那么B这个函数调用结束之后应该返回到A的哪一句代码，需要把这个函数的返回位置也在堆栈里边记录下来，同时每一
  层函数的局部变量也会放在堆栈里边。 

* 线程的堆栈可能是比较大的，是内存里的一大片区域，如果把这整片区域都全部把它放到TCB里， 显然没必要，只需要保存堆栈指针 就可以，保存一个指针，可以通过指针来找到线程，它的堆栈在内存里的哪个位置，哪片区域就可以了。 所以还需要保存堆栈指针，所以这个地方我把这三个部分圈起来了，程序计数器PC以及其他各种寄存器的值还有堆栈的信息，这些是线程切换的时候，我们需要保存和恢复的一些线程的运行环境。 

* 下处理机的线程需要把这些信息保存到TCB当
  中。而上处理机的线程需要从TCB当中取出这些信息，然后把这些信息填回到相应的位置，堆栈指针通常是把它恢复到SP堆栈寄存器里边的。 

* 除了上面这些信息之外，TCB当中还需要保存运行状态，运行态就绪态还是阻塞态，甚至如果是阻塞态的话，还可以把阻塞的原因什么的，就是更详细的给它进行一个记录。最后还需要保存线程的优先级，通常在线程调度或者系统在分配资源的时候可以根据线程的优先级来进行分配或者制定一个策略。 

* 这就是TCB当中大致需要包含的一些内容，有了TCB之后，每一个TCB这种数据结构就可以 表示一个线程，把多个线程的TCB给组织起来，就可以形成一个线程表。 组织的方式有很多种，比如说每个进程给它设置一张线程表或者系统当中所有的线程组成一张线程表。 当然，也可以按照线程的状态不同，组织成不同的线程表，不同的系统可以采取不同的策略。 总之，线程的组织就是按照你的需求把各个TCB有规律的，分门别类的，把他们组织起来分类管理， 这就是线程的组织。 

* 线程的控制就是要让线程在各种状态之间来回切换，这就是线程的控制

* 所以这两个部分新增的内容，无非是把进程变成了线程而已。而线程往往比进程还要更简单。