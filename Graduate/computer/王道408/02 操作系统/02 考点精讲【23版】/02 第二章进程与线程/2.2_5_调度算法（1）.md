# 调度算法 先来先服务 最短作业优先 最高响应比优先



## 知识总览

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305171102863.png" alt="image-20230517110212708" style="zoom:50%;" />

* 学习几种调度算法，分别是先来先服务，短作业优先和高响应比优先，这三种算法。 
* 在学习这个小节的过程中，会按照一定的框架思路来依次分析各个算法。 首先，会介绍每一种算法的提出是想解决什么问题，出于什么目的而提出的这个算法，然后出于这个目的，又采用了什么样的算法规则
* 之后，这些算法到底是用于作业调度还是用于进程调度，用于作业调度和进程调度的时候有没有什么区别也是需要关注的一个问题。 
* 之后各个算法可能会有抢占式的版本和非抢占
  式的版本，这个就是之前介绍的调度方式强调的两个知识点，抢占式和非抢占式。 
* 另外，在考试的选择题当中，还经常会考察各个算法的优点和缺点，所以这个也很重要。 
* 第六个会重点关注一下各个算法有没有可能导致饥饿的问题， 饥饿这个概念之前还没有提过，其实很简单就是指如果一个进程或者一个作业长期得不到服务。那么，这个进程或者说作业， 就处于饥饿的状态，那么会按照这样的框架来依次分析各个算法。 
* 首先来看，先来先服务算法。

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305171115433.png" alt="image-20230517111527318" style="zoom: 67%;" />

* 这个算法的思想其实和日常生活中排队买东西特别类似，主要是从公平的角度来考虑，和它的名字一样也就是说先到达就绪队列或者先到达后备队列的进程或者作业就先为他提供服务，那么当用于作业调度的时候考虑的其实是哪一个作业先到达后备队列，这个后备队列是在外存中的，在上一个小节也强调过这个知识点，如果说是用于进程调度的话，那么考虑的是哪一个进程先到达的就绪队列， 就绪队
  列是在内存中的，这是当它作为作业调度或者
  进程调度的时候，有的一个小小的区别， 另外先来先服务算法，一般是非强占式的算法，也就是说，对于当前正在占用处理机的进程或者说作业。那么，只有进程主动的放弃处理机的时候才会进行调度，才会用调度算法的规则来选择下一个应该得到服务的进程。 

* 直接来看一个具体的例子，可能会更容易理
  解。 

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305171122481.png" alt="image-20230517112216359" style="zoom: 50%;" />

* 有这样几个进程P1到P4进程，它们的到达时间和运行时间分别是这样的数据，这个时间大家认为是秒或者毫秒都可以，这个无所谓。

* 那么， 如果采用的是先来先服务的调度算法。一会儿会计算一下这些进程的等待时间，平均等待时间，周转时间，平均周转时间，还有带权周转时间这些在之前的小节当中介绍过
  的评价一个调度算法的指标，先来先服务调度算法的规则很简单，其实就是按照到达的先后顺序依次进行调度，因为他是到达的先后顺序，所以事实上他考虑的是哪一个进程它到了之后，等待的时间更长，等待时间越久的进程就会越优先的得到服务，那么这是先来先服务调度算法考虑的一个点，也就是考虑的是各个进程或者作业的等待时间。 所以这个调度顺序其实很容易就看出来，就是根据到达顺序0245，它们P1P2P3P4是依次到达的，所以会按这样的顺序进行调度。

* 那么P1从0时刻到达就开始运行，然后运行了七个时间之后，P2是第二个被调度的，它会运行四个时间，之后是P3运行一个时间，然后P4运行四个时间，就是这样的顺序，那么来计算一下这几个指标，周转时间其实就是用各个进程的完成时间减掉到达时间，P1是在7这个时刻完成的。 而它到达的时间是零，所以P1的周转时间就是7-0，也就是七，而P2是11这个时刻完成的，但是它到达的时间是2。 所以P2的周转时间就是11-2,也就是九，那么p3和p4这些也是类似的，而带权周转时间和周转时间是不一样的。 带权周转时间要用周转时间除以运行的时间，那么P1周转时间是七，它运行的时间也是七，所以p1的带权周转时间是一。P2P3p4这些大家再具体思考一
  下，这就不展开了，等待时间的话在这个题当中比较简单，可以直接用周转时间减掉运行时间，其实就是各个进程的等待时间，所以把上面的这些式子依次的除号变成减号，然后一计算就可以得到各个进程的等待时间分别是多
  少，但是大家需要注意的一点是， 在这个题目当中给出的这个例子当中的这些进程其实都
  是纯计算型的进程， 也就是说这些进程其实只需要CPU为他们服务。 所以说一个进程在它到达以后肯定只会有两个状态，要么它就是在等待被CPU处理被调度，要么它就是处于运行的状态，所以对于这个题目这种纯计算型的进程来说，只需要用整个周转时间来减掉它的运行时间，那么剩下的肯定就是等待时间这个部分，但是有的题目可能会给出的是一些既有计算还有IO操作的这些进程，那么在计算这些进程的等待时间的时候，就不能简单的用周转时间减去运行时间这样来计算，需要用周转时间，也就是整个完成时间到到达时间这个总的时间段的长度减掉它在CPU上运行的时间，还要再减掉IO设备为它服务的时间，这样得到的才是这种又有计算又有IO操作的进程的等待时间，这个地方大家稍微注意一下。 所以这个公式不要认为它是一成不变的，要具体问题具体分析，这种例子暂时不展开，如果在课后习题遇到的话，大家自己再巩固一下。 

* 平均周转时间平均带权周转时间，还有平均等待时间计算起来就很简单了，其实就是把他们这些数据全部加起来，然后除以进程的个数4，分别得到的是这样的数据现在先不用关心，一会儿这些数据还会再列出来，所以这就是先来先服务算法具休的调度的规则。 很简单， 就是按照到达的时间顺序或者说等待的时间越久的进程，它就越发排在前面，就是按照这样的规则来进行调度的，那么在这个地方，大家可能会注意到一个点，就是对于p3
  这个进程来说，在计算它的带权周转时间的时
  候。 这个权值计算得了八是非常大的一个
  值，因为带权周转时间其实表示的是这个进程的整个周转时间比运行时间要大多少倍，这样
  一个指标，所以说带权周转时间这么大，也就意味着这个进程本来只需要很少的时间为他服务，但是他需要等很长的时间才可以被处理完。 因此，对于P3这个进程的用户来说， 可能他的体验就是特别糟糕的。 
  
* 那么接下来再来继续讨论一下它的优缺点

* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305171146260.png" alt="image-20230517114607146" style="zoom:50%;" />

* 优点的话其实就很公平，因为类似于平时排队买东西，先到的先被服务，而且这个算法其实很简单，实现起来也不复杂，缺点就是刚才提到的P3那个进程带权周转时间算出来会特别的大，也就是说对于一个排在长作业后面的短作业，或者排在长进程后面的短进程来说，它需要等待很长的时间才可以被服务，那么对于短进程或者短作业的用户来说，体验会特别糟糕，所以先来先服务算法，其实是对长作业有利，对短作业不利的，这个地方为了让大家能够有更感性的体验，来举一个排队买奶茶的例子。假如说去某一个奶茶店排队买奶茶，那么一般来说他们采用的规则就是先来先服务，先到的肯定先给你做奶茶。 但是如果这个时候你的面前突然出现了一个要买20杯奶茶，那么这家店可能做这20杯奶茶需要半个小时的时间。 虽然说你只买一杯奶茶，做你的奶茶的时间只需要一分钟， 但是由于你的前面突然出现了一个长作业，或者说长进程。 所以对于短作业或者短进程来说，体验就会特别糟糕，可以算一下带权周转时间就会特别大。 所以是对长作业有利，对短作业不利的，这样讲可以体会到什么叫有利，什么叫不利了，对于先来先服务算法来说，其实是不会导致饥饿的，因为不管是哪一个作业，只要一直等着，他前面的那些作业或者进程总会被处理完，所以他是不会导致饥饿的，因为不管是哪一个作业，只要一直等着，他前面的那些作业或者进程总会被处理完，所以他
  是不会导致饥饿的。

* 这就是先来先服务算法。 那么，从刚才这个例子，已经知道先来先服务算法， 对于带权周转时间，还有平均等待时间， 这些指标其实是不太优秀的， 所以短作业优先算法的提出， 其实就是为了追求更少的平均等待时间，还有平均周转时间， 平均带权周转时间。 

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305301118436.png" alt="image-20230530111843326" style="zoom: 50%;" />

* 短作业优先算法的规则也很简单， 就是最短的作业或者进程优先得到服务，而这个地方所谓的最短其实是指这个作业或者说进程， 它要求服务的要求被服务的时间最短的那个优先得到服务。 那么短作业优先算法是用于作业调度的， 当然也可以， 这种规则就是最短的优先被服务， 这种规则也可以用于进程调度， 但是用于进程调度的时候一般是称为短进程优先算法。 也就是SPF，J指的是Job，然后这个用作进程调度的话，这个P指的是Process就是进程。
* 短作业优先算法默认一般来说是非抢占式的，但是也有短作业优先算法的抢占式版本称为最短剩余时间优先算法SRTN，这是它的英文缩写，那么具体来看一下，用一个例子来看一下这两种算法到底有什么区别？
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305301119279.png" alt="image-20230530111954172" style="zoom:50%;" />
*  还是刚才的题目只不过把它改成了使用非抢占式的短作业优先算法， 也就是SGF这个算法。这个例题当中给出的是用于进程调度的这种场景， 所以这个地方严格来说，应该是使用非抢占式的短进程优先调度算法，而不是短作业优先。 不过，很多题目中也不会太在意这个细节， 大家只需要知道它们的规则其实是一样的。 就是根据要求服务时间，也就是运行时间来做优先级的排列就可以了，这个调度算法就是每一次调度的时候会选择当前已经到达的，注意是当前已经到达的，并且运行时间最短的一个作业或者进程为他进行服务分配处理机。 所以这个调度顺序也很好确定，在零这个时刻只有p1这个进程是已经到达的
* 所以这个时候只能为P1这个进程服务只能调度P1，所以第一个进程肯定是P1当P1运行完了之后，也就是到了时刻7。 这个时刻，其他的这些所有的进程全部都已经到达了，但是p3要求运行的时间是最短的，所以p1之后会调度p3。 当p3运行完了之后，还剩p2和p4两个进程，但是由于p2是先到达就绪队列的，所以虽然它俩的运行时间是一样
  的，但是会优先调度p2这个进程。
* 因此，整个过程的运行情况是这个样子，
  这个地方可以用这个图结合各个进程的到达
  时间来很快速的算出每个进程的周转时间、带权周转还有等待时间分别是多少，并且把这些指标加和再除以四之后就可以得到平均周转， 平均带权周转和平均等待时间，这个地方大家也最好自己动手算一下。 
* 和之前先来先服务算法得到的这三个指标来进行一个对比会发现采用了非抢占式的短作业优先算法之后，平均周转时间从8.75 降
  为了8平均带权周转从3.5降为了2.56，而平均等待时间从4.75降为了4。 所以从这三个指标来看短作业优先算法在这些方面的表现，是要优于先来先服务算法的。
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305301129113.png" alt="image-20230530112913019" style="zoom:50%;" />
* 如果采用的是抢占式的短作业优先调度算法，抢占式的短作业优先，刚才也已经强调过， 它也有另外一个名字叫做最短剩余时间优先算法。 英文缩写是SRTN用这个算法的话，由于它是抢占式的，所以每当有一个新的进程进入到就绪队列的时候会引发就绪队列改变，当就绪队列改变的时候就需要看一下这个新来的进程，到底会不会抢占处理机？所以当这个就绪队列改变的时候，我们就需要计算一下当前新到达的那个进程，它的剩余时间，剩余的运行时间比起当前正在运行的这个进程剩余的时间到底是不是更短？ 如果更短的话， 我们就会把新来的这个进程让它抢占处理机，所以这就是抢占式造成的结果，那么当前正在运行的进程如果被抢占处理机之后， 它就会回到就绪队列当中。 另外呢， 如果说当前运行的进程主动放弃处理机的时候， 也就是一个进程正常完成的时候也需要用这样的调度算法来
  进行一个调度， 所以这是这种算法当中我们需要注意的两个时间点，一个是就绪队列改变的时候，另外一个是一个进程完成的时候，那么按照这样的规则来依次分析一下各个时刻。 
* 首先在零这个时刻，只有p1到达，那么pl当前的剩余时间也就剩余的运行时间，就是整个也就是七个时间。 那么就是这个样子，所以此时因为只有p1在就绪队列当中，当然是为p1分配处理机p1上处理机运行。
* 但是当p1运行了两个时间，两个单位的时间的时候在二这个时刻p2到达了就绪队列，因此就发生了就绪队列改发生了改变这样的事情，所以这个时候系统会重新计算一下，当前正在运行的这个进程p1剩余五个时间，五个单位的运行时间，而新到达的进程p2，只剩余总共四个单位的时间，所以p2的剩余时间更短，因此会选择p2这个进程， 让他抢占处理机，然后p1重新回到就绪队列。 同样的，到四这个时刻，虽然p2还没有完成，但是p3这个进程到达。 
* 由于此时p3的运行，剩余运行时间比起其他进程来说是最少的，所以这是这个时候p3正常的被抢占处理机，到第五这个时刻，p3正常完成了，但同时p4进程它也在五这个时刻
  到达。 所以此时就绪队列中剩余pIP2P4这样四个进程，但是p2之前已经运行了两个单位的时间，它在运行两个单位的时间就可以了，所以p2又会被分配处理机p2运行。
* 在p2运行了剩余的两个时间之后又剩下p1和p4，再一对比， 又是p4的剩余时间最短， 所以p4又会上处理机运行， 当p4运行完了之后才是最后再把p1上处理机。 处理机把剩下的这五个单位的时间运行完， 所以整个过程就是这个样子， 大家再结合刚才的分析， 也可以动手画一下。 
* 这个地方我们可以结合这个图和各个进程的到达时间就可以很方便的算出之前提到过很多次的这一系列的指标。
* 这个地方需要注意的是抢占式的短作业优先算法中这些进程的执行可能是断断续续的， 比如说p1执行了这样一段，还有这样一段，p2也是执行了这样两段，这和之前介绍的那两种算法是不太一样的，所以对于这个算法的这些指标的计算， 大家也要自己动手算一下， 看看能不能得到正确的结果，再把之前非抢占式的短作业优先得到的这三个指标把它们放在一块儿，会发现采用了抢占式的短作业优先， 或者说最短剩余时间优先之后得到的平均周转， 平均带权周转， 还有平均等待时间这三个指标比非抢占式的还要更小， 也就意味着采用抢占式的这种算法之后，它在这些方面的表现要优于非抢占式的短作业优先算法。 
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305301149402.png" alt="image-20230530114957308" style="zoom: 50%;" />
* 所以这个地方大家除了了解这两种不同的抢占式和非抢占式在具体的做题的过程当中有什么区别之外，还需要注意几个小细节。 
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305301304066.png" alt="image-20230530130448948" style="zoom:50%;" />
* 如果说在题目当中提到短作业优先或者短进程优先算法的话， 那么默认的其实是非抢占式的。 但是在很多书上， 包括王道书上，会看到这样的一句话， 就是短作业优先算法的这种算法得到的平均等待时间和平均周转时间是最少的，但是根据刚才计算的结果可以看到其实最短剩余时间优先算法所得到的平均等待时间和平均周转时间还要更少。
* 所以这句话其实严格来说是错误的，不严谨的。 如果要让这句话变得更严谨一点应该加一个条件， 在所有的进程同时可运行的时候。采用短作业优先调度算法所得到的平均时间或者平均周转时间是最少的。 或者还可以改一种说法， 如果说所有的进程几乎都是同时到达的， 那么采用这种算法得到的平均等待时间和平均周转时间是最少的。为什么要强调用一个几乎这样的表述呢？ 因为进程的到达肯定还是有先后顺序的，只不过在宏观上看，可以认为连续到达的那些很快速的到达那些进程，几乎是同时到达的。 然而，事实上也会有先后顺序只不过是微观上看有先后顺序，宏观上看这些进程几乎同时到达。
* 还有另外一种说法。 如果说不要所有的进程都几乎同时到达这个条件的话，可以说抢占式的， 就是刚才所提到的最短剩余时间优先这个算法所得到的平均等待时间和平均周转时间是最少的，这个是没有问题的，如果数学基础好的同学可以试试看能不能证明这个算法为什么是平均等待时间、平均周转时间最少。
* 第三点，虽然短作业优先算法的平均等待时
  间，平均周转时间不一定是最少的。这个刚才已经说过，但是相比于像先来先服务，还有最高响应比优先相比于这样的算法来说，短作业优先算法其实仍然是可以获得比较少的平均等待时间，平均周转时间这两个指标的。 所以在有的题目当中，有可能会遇到刚才说的这个这句话这样的选项，如果说遇到这样的选项的话， 大家一定要再判断一下其他的三个选项是不是有很明显的错误， 如果别的那些选项都错的很明显的话， 那也可以选择这个选项，认为它是正确的。 因为操作系统这门课，其实和像物理、数学这些基础理学的这些学科不太一样，对于很多概念，
  很多算法的一些说法， 定义可能不同版本的教材也会有所不同，所以它并没有一个很严格说法，所以大家在做课后习题的时候可能也会发现有一些在之前讲的，还有课后习题当中说法不一致， 前后有那么一点点矛盾的那种现象， 大家需要学会适应这种情况，在考试的时候最好就是判断一下所有的选项，然后选一个错误更少的更合适的选项。 
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305301324397.png" alt="image-20230530132440256" style="zoom:50%;" />
* 经过刚才两个例题，相信大家对这个算法强占式和非抢占式到底应该怎么做应该已经有了一个比较直观的理解。
* 所以短作业优先算法的优点就是可以得到最短的平均等待时间和平均周转时间，这个最短为什么打双引号呢？ 这个应该已经知道了。在遇到的时候稍微注意一下，知道一个这句话不严谨这样的一个细节就可以了，而缺点的话其实也很明显， 就是对于短作业有利， 长作业不利。 如果说这个就绪队列中源源不断的有更短的作业到来的话，那么就有可能会产生长作业饥饿的现象，另外呢，像这个作业或者进程的运行时间其实是由用户提供的一个数据。 所以这个用户可可以把自己本来应该是长作业，但是把自己提交的这个数据把它写的很短，所以事实上短作业优先这种算法并不一定真正的能够做到短作业优先这件事。 是否会导致饥饿呢？ 刚才已经说了，是会导致饥饿的并且如果一个进程或者一个作业他一直得不到服务的话，是一直得不到服务的话， 那么这种更加严重的饥饿现象就可以称作进程饿死或者作业饿死。这就是短作业优先算法
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305301332961.png" alt="image-20230530133255777" style="zoom:50%;" />
* 经过刚才的讲解会发现对于先来先服务和短作业优先这两种算法来说，先来先服务算法，每次调度的时候，其实考虑的是每一个作业或者进程的等待时间哪一个最长？ 他考虑的是等待时间，但是对于每一个作业的运行时间到底是长是短这些他并不关心。 所以这就导致了这个先来先服务算法对长作业友好，对短作业不友好的问题。相反的，短作业优先这个算法， 它又是只考虑了一个作业或者进程的执行时间。 他每一次都是给估计的执行时间，估计运行时间最短的那个作业或者进程来调度他的，所以他并不考虑每一个进程到底等待了多长时间，所以这就会导致另外一个相反的问题， 就是对长作业不友好，甚至还会导致长作业饥饿的这种现象。 那么能不能设计一种算法， 既考虑到每一个作业的等待时间， 同时还能兼顾每一个作业或者说进程的运行时间呢？因此，人们就用这样的想法提出了高响应比优先算法。 
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305301638221.png" alt="image-20230530163829056" style="zoom:50%;" />
* 高响应比优先算法就是刚才所说的这样的一个思想， 既要考虑它的运行时间，还要考虑到要求服务的时间，也就是估计的运行时间。 这个算法的规则就相对来说要复杂一些，在每一次调度的时候，会计算各个当前已经到达的这些进程或者作业的响应比，然后选择一个响应比最大的最高的进程为他们服务，响应比的计算方式是这样的。 等待时间加上要求服务时间或者说运行时间，再除以要求服务时间，从这个式子当中也会发现响应比肯定是一个大于等于一的数，因为等待时间是一个正的，然后要求服务时间上下都有，所以分子肯定要比分母更大。 这个算法既可以用于作业调度，也可以用于进程调度，这个算法一般来说是非抢占式的， 所以只有当一个作业或者一个进程主动的放弃处理机的时候，才需要使用调度算法来计算各个进程的响应比。
* 为了让大家更直观的理解，还是用刚才的
  例题。 
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305301644232.png" alt="image-20230530164411105" style="zoom:50%;" />

* 这些进程的到达时间和运行时间还是一样的，使用的是高响应优先算法，这个算法
  就是当一个进程主动的放弃CPU的时候，也就是当它正常或者异常的完成终止，或者说， 当这个进程主动的要求阻塞的时候，才需要使用调度算法来计算各个进程的响应比，但是这个题目当中，由于它是纯计算型的一些进程， 所以，并不会有IO操作，也就是并不会主动的要求阻塞， 因此这个情况，暂时不需要考虑。 
* 响应比的计算公式是刚才说的这个样子， 所以在零这个时刻， 由于整个系统的就绪队列当中只有p1是到达的。 所以管它p1的响应比到底是多少，肯定是p1上处理机，然后由于它是非抢占式的算法， 所以只有p1主动地放弃CPU，也就是p1运行了七个单位的时间，当它结束的时候才会进行第二次调度， 那第二次7这个时刻会发现就绪队列当中有p2p3p4这样三个进程。 p2是从2这个时间点到达的，然后一直到了7这个时间点，这个时候到这个时候它总共等待了7-2， 也就是五个单位的时间。 然后它要求
  服务的时间是四，然后再除以要求服务时间是四就可以得到2.25，p3p4这些也是一样的， 大家再自己分析一下，经过计算会发现p3这个进程的响应比是最高的，所以让p3上处理机运行，然后p3的运行时间只有一个单位的时间，所以当他主动放弃处理机的时刻就是八这个时刻。还剩下p2和p4两个进程，那么还是用刚才相同的规则再来计算，发现p2的响应比要更高， 所以p2又上处理器运行。 然后p2执行了四个时刻，之后，12这个时间p2完成，就绪队列里就只剩下p4这个进程了，所以当然也不用计算它的响应比，p4肯定是下一个上处理机运行的进程。 所以整个过程就是p1p3P2P4
* 这个地方可能会发现响应比这个公式， 它是等待时间加上要求服务时间再除以要求服务时间，所以p2和p4这两个进程，他们的要求服务时间也就是运行时间其实是相等的，那既然p2先到达就绪队列的话，那么就意味着p2的等待时间是要更大的，而另外的要求服务时间，他们都是相等的，所以p2的
  等待时间更大的话，当然p2的响应比计算出来肯定也更大，看这个时刻p2是2.25，p4是1.5，然后这个时刻p2是2.5，p4是1.75，他肯定都是大于p4的，所以这是响应比优先计算响应比的特点，具体的运行就是这个样子，就不再展开了。 
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305301709932.png" alt="image-20230530170924832" style="zoom:50%;" />
* 所以响应高，响应比优先这个算法， 它综合考虑了一个进程， 或者说作业的等待时间和要求服务时间。 在两个进程等待时间相同的情况下，要求服务时间更短的那个进程计算出来的响应比会更大。 所以要求服务时间更短的会优先，这也是我们短作业优先算法的一个优点。
* 另一方面， 如果要求服务时间一样的话，那么就像刚才聊到的p2和p4两个进程一
  样，等待时间更长的会优先，所以这又是先来先服务那个算法的优点，所以这个算法其实是综合了前两个算法的优点，然后做了一个折中的处理。
* 对于一个长作业来说，随着等待时间越来越大，那么它的响应比肯定也会越来越大，所以它被调度的机会也会越来越高，所以这个算法也避免了短作业优先这个算法造成的长作业饥饿的问题，所以这个算法其实是不会导致饥饿的
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305301712416.png" alt="image-20230530171230306" style="zoom: 50%;" />
* 这个地方对这几个算法做了一个简要的总结，对于这些算法的思想还有这些算法具体怎么算，怎么做题这个规则大家需要自己回忆，并且一定要结合课后习题来进行巩固。 
* 这个地方需要注意的是短作业优先算法得到了最短的平均等待和平均周转时间， 这个最短的为什么打双引号？大家再思考一下，回忆一下。 其实这三种算法主要关心的是对用户作业或者用户进程的一种公平性的问题， 就像先来先服务这种，它要求绝对的公平。 
* 另外这几种算法还追求平均周转时间，平均等待时间这些，这些其实都是用来评价系统的整体性能，整体表现的这指标。 
* 所以这几种算法大家会发现它其实并不关心响应时间，并且也不会区分各种任务的紧急程度。 所以这三种算法对于用户来说其实是基本没有交互性的， 交互性特别糟糕，那么这三种算法它一般就是使用在早期的批处理系统当中。 因为在早期的批处理阶段，其实计算机也很昂贵，所以人们更追求系统的整体表现，而不是对于各个用户，对于各个用户来说的一种用户体验，其实也是情有可原的， 这几种算法当中先来先服务这个算法现在也经常会结合其他的一些算法
  来使用，所以先来先服务算法在现在的计算机当中也扮演了很重要的角色。
* 除了批处理系统使用的调度算法之外， 下面一个小节还会继续介绍适合适用于交互式系统的一些调度算法。 这个地方强调一下，在学习这个小节，还有下一个小节的这些调度算法的时候， 大家一定要尝试动手输出一下。