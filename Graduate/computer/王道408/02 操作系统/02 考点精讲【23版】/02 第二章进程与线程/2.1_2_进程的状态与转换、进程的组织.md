# 进程的状态与转换



## 知识总览

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111521732.png" alt="image-20230511152142647" style="zoom: 67%;" />

* 在这个小节中会学习进程的状态和状态转换相关的知识点。会介绍进程所拥有的各种各样的状态和它们之间在什么情况下需要转换，另外还会介绍进程的组织方式的问题，也就是各个进程的PCB之间要用什么样的方式把它们组织起来的一个问题



## 进程的状态——创建态、就绪态

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111529716.png" alt="image-20230511152923637" style="zoom: 67%;" />

* 首先来看一下进程有哪些状态，在上个小节当中提到过，程序也就是可执行文件平时是存放在硬盘里的，而当这个程序想要执行的时候，需要把这个可执行文件调入内存，同时操作系统会为它建立相应的PCB，也就是建立一个相应的进程。 当一个进程正在被创建的期间，这个进程的状态就是处于创建态。在这个阶段，操作系统会给这个进程分配相应的系统资源。 比如说给它分配一些内存空间，另外在这个阶段操作系统也会完成对PCB的一个初始化的工作。 

* 当一个进程完成了创建工作之后就会进入一个新的状态， 叫做就绪态。 处于就绪态的进程，其实是已经具备了运行的条件，只不过此时CPU比较忙还没有空闲，所以CPU暂时不能为这个进程服务

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111533706.png" alt="image-20230511153342604" style="zoom: 67%;" />

* 一个系统当中可能会有很多很多个处于就绪态的进程，当CPU空闲的时候，操作系统就会从这些处于就绪态的进程当中选择其中的一个让它上CPU运行，而如果一个进程此时正在CPU上运行的话，那么这个进程就处于运行态

* 经过之前的学习知道一个进程正在运行意味着此时CPU正在处理这个进程背后的程序，也就是CPU正在执行这个进程相应的那些指令序列比如说CPU执行了进程2的指令一，指令二，指令三。假设此时进程二的指令三是发出了一个系统调用，而这个系统调用是请求操作系统给他分配打印机资源，而此时打印机设备很忙，正在为别的进程服务。 

* 所以这个打印机资源暂时不能分配给进程二，所以这个进程二接下来的这个指令也就是要往打印机输出数据这条指令就没办法往下执行，既然这个进程接下来的这些指令暂时不能往下执行的话，那么显然不应该让进程一直占用着CPU资源。 

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111541623.png" alt="image-20230511154147528" style="zoom: 80%;" />

* 所以类似于刚才所说的这种情况，很多时候进程在运行的过程当中，有可能会请求等待某个事件的发生。比如说像刚才所说的它会等待系统给它分配某一种系统资源或者它需要等待其他进程的响应等等。

* 总之，这个进程在运行的过程当中，有可能会主动的请求等待某个事件的发生，而当这个事件发生之前这个进程是没有办法继续往下执行的，所以在这个时候操作系统就会剥夺这个进程对CPU的使用权，然后让这个进程下CPU，并且让它进入到一个新的状态，叫做阻塞态，也就是说这个进程因为等待某个事件而被阻塞了，当这个CPU再次空闲之后，操作系统又会选择一道处于就绪态的进程，让它上CPU运行。
  
* 接下来的故事是这样的，这个打印机设备之前正在为别的进程服务，如果说这个打印机的服务已经结束，那这个打印机就会空闲下来。所以当打印机空闲下来的时候，它就可以分配给刚才请求打印机的那个进程，也就是进程二。 所以当操作系统把这个打印机资源分配给进程二的时候，这个进程二等待的事件其实就已经发生了。此时，操作系统会让这个进程二从阻塞态再次回到就绪态。 也就是说，当它等待的这个事件发生了之后。这个进程就再次拥有了上处理机运行的条件

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111547329.png" alt="image-20230511154730263" style="zoom: 67%;" />

* 让这个故事继续下去。 假设此时正在CPU上运行的这个进程，进程一已经运行结束了，在它运行结束的时候，它会发出一个叫做exit的系统调用，这个系统调用其实就是要请求操作系统终止这个进程。 此时这个进程的状态就会变成终止态，然后操作系统会让这个进程下CPU并且做一系列的善后的工作，会回收这个进程所占有的各种资源包括内存空间，打印机设备等等。 
* 总之，所有的资源都需要回收，并且最后它还会回收这个进程的PCB，而当终止进程的这些工作完成了之后，这个进程就从这个系统当中彻底消失了。

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111551420.png" alt="image-20230511155120344" style="zoom: 67%;" />

* 用一个图把刚才所提到的这些进程的状态和它们的转换，再给串一下。 
* 一个进程在运行之前需要被创建，在创建的过程当中，系统会完成一系列相应的工作，包括新建PCB还有给这个进程分配一系列的资源等等，如果一个进程正在被创建的话，这个进程此时就是处于创建态的。 当一个进程被创建完毕之后，就拥有了可以上处理机，上CPU运行的这种条件，这个时候进程就进入了就绪态，也就是说处于就绪态的进程， 其实只差处理机这种资源，其他它所需要的资源，它已经都具备了，如果处于就绪态的进程被操作系统调度，这个进程就可以上处理机运行。 当它在处理机上运行的时候，它就处于运行态，也就是说正在处理机上运行的进程，其实是既拥有了它所需要的其他所有的那些条件和资源，同时它也拥有了处理机这种资源，而有的时候正在运行的进程， 可能会请求等待某些事件的发生，在这个事件发生之前，这个进程是没有办法继续往下执行的，所以在这种情况下，进程不应该一直占用着处理机资源， 所以此时这个进程应该被剥夺处理机资源，同时除了处理机资源之外，它还在等待其他的某一种资源， 或者说等待其他的某一种事件的发生。 
* 如果说处于阻塞态的进程等待的事件发生了，这个进程就可以从阻塞态又回到就绪态。当他回到就绪态，就说明这个进程他已经拥有了除了处理机之外的所有的他想要的那些资源。所以从刚才的这个讲解过程当中会发现运行态到阻塞态的转换其实是进程自身主动的一种选择，主动的行为。 一般来说都是进程通过系统调用的方式来申请某一种系统资源或者请求等待某个事件的发生，所以这个转换的过程是进程主动选择的，而阻塞态到就绪态的转变，它并不是进程自身能够控制的，比如说一个进程，它正在等待打印机资源。那么，这个打印机资源什么时候分配给它，这并不是这个进程能够说了算的，所以阻塞态到就绪态的转换是一种被动的行为。 并不是进程自己可以控制的， 所以大家需要注意的是一个进程不可能直接从阻塞态转换为运行态。也不可能直接从就绪态转换为阻塞态，因为进程要变成阻塞态，肯定是需要进程主动请求。 而进程要发出这种主动请求，那就意味着这个进程肯定是正在CPU上运行才可能发出这种主动请求。 所以说只可能从运行态转换成阻塞态，而不可能从就绪态转换成阻塞态，在之前的讲解中，也提到过处于运行态的进程，它可以主动的请求运行结束，或者说如果一个进程在运行的过程当中遇到了一些不可修复的错误，比如说整数除以零这样的错误，在这种情况下，这个进程也应该被终止，在操作系统对这个进程做相应的终止工作的时候，这个进程就处于终止态，此时操作系统会回收进程所拥有的各种资源，并且会撤销它的PCB。
* 最后还要强调一个刚才没有提到的状态的转换，有的时候进程可以直接从运行态转换成就绪态。 比如说操作系统给进程分配的时间片用完了的时候进程就会从运行态转换成就绪态，什么叫时间片用完呢？在第一章当中提到过时钟中断，一个进程本来正在处理机上运行的好好的，但是此时如果CPU收到一个时钟中断的信号，然后发现这个进程已经运行了很长时间了不应该让它继续往下执行了，这种情况就是时间片到，时间片用完的一个状态。此时这个进程就应该被剥夺CPU的使用权，让它从运行态又回到就绪态。 因为在这种情况下，其实进程它还是拥有继续往下执行的条件。 它只不过是被剥夺了处理机而已，它并不需要再等待除了处理机之外的其他的事件发生，因此进程是从运行态回到了就绪态。在这儿涉及到了进程的五个状态， 这就是经典的进程五状态模型。 

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111610149.png" alt="image-20230511161056042" style="zoom: 67%;" />

* 在这五种状态当中运行态、就绪态、阻塞态是基本状态，因为进程的整个生命周期当中，其实大部分的时间是处于这三种状态的，所以它们是基本状态。
*  另外，需要强调一点，在单CPU的环境下，处于运行态的进程同—时刻最多只会有一个，而如果系统是多核CPU的话就意味着多个进程可以并行的运行，在这种情况下就会有多个进程处于运行态。 
* 另外一点需要强调的是阻塞态又可以称为等待态， 创建态又可以叫新建态，终止态又可以叫结束态，所以它们的这些别名大家也稍微注意一下。
* 操作系统是怎么记录进程的这些状态的呢？在上个小节当中有提到过在进程的PCB当中会有一个变量state。 这state就是用来表示进程的当前状态，比如说可以用一表示它处于创建态，然后二表示它处于就绪态等等。
* 另外操作系统会把处于同一个状态的各个进程的PCB有规律的组织起来，这样的话可以方便统一的管理。 
* 所以怎么把各个进程的PCB组织起来这个问题就是进程的组织想要探讨的问题，进程的组织方式有两种， 一种是链式方式，一种叫索引方式。 

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111619410.png" alt="image-20230511161914327" style="zoom: 67%;" />

* 链式方式就是指操作系统会管理一系列的队列，每一个队列都会指向相应状态的这些进程的PCB，比如说有一个执行指针指向的这个PCB就是此时处于运行态的进程的PCB。而就绪队列指针所指向的这个队列就是此时系统当中处于就绪态的这一些进程PCB队列。
* 为了方便对这些就绪进程的调度，操作系统经常会把优先级更高的那些进程的PCB放在这个队列的队头。阻塞队列指针也一样，它指向的就是此时处于阻塞状态的那些进程的PCB。而在很多操作系统当中，它还会根据阻塞原因的不同， 再把阻塞队列分成多个，比如说像这个样子。

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111623146.png" alt="image-20230511162334043" style="zoom:67%;" />

* 这两个进程，他们是因为正在等待打印机资源而阻塞的， 所以他们会放在等待打印机的这个阻塞队列当中。 而这个进程是正在等待磁盘这种资源，所以它放在了等待磁盘的这个阻塞队列当中。
* 总之，操作系统用这样的方式把各个状态的进程PCB，把它们有规律的组织起来，这样可以方便操作系统对这些进程进行统一的管理

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111625711.png" alt="image-20230511162531651" style="zoom: 67%;" />

* 除了链式方式之外，另一种组织方式叫做索引方式，操作系统会给各种状态的进程建立相应的索引表，然后每一个索引表的表项又会指向相应的PCB，就像这个样子，索引方式通过这张图就很容易理解了。 但是大多数的操作系统都是使用的链式方式，所以这个地方有一个简要的了解就可以了。 

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111627722.png" alt="image-20230511162748642" style="zoom: 67%;" />

* 进程的组织方式这一块的内容，只要稍微有个印象就可以，总之他回答的就是操作系统应该怎么把各个进程的PCB组织起来这样的一个问题。

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305111629081.png" alt="image-20230511162947765" style="zoom: 67%;" />

* 这个小节当中更值得注意的还是进程的状态，还有进程状态之间的转换这样的问题，绿框部分是我们考研当中最喜欢考的最高频的考点部分。 