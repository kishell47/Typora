# 进程通信（IPC）



## 知识总览

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121622221.png" alt="image-20230512162215148" style="zoom:50%;" />

* 在这个小节中会学习进程间通信的几种方式，分别是共享存储，消息传递，还有管道通信。



## 什么是进程间通信？

* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121635526.png" alt="image-20230512163519423" style="zoom: 50%;" />
* 进程之间的通信指的就是两个或者多个进程之间产生了数据交互，在一个系统当中可能会同时存在多个进程。多个进程都在运行，这些进程之间难免需要相互配合着工作， 在这种情况下，进程和进程之间的数据通信就显得很有必要了。
* 比如说， 当我们在玩微博的时候，可能你会看到一篇某明星的八卦，一个吃瓜的文章，想把这个文章分享给你的微信好友，可以直接使用微博应用里面内置的一个分享功能，然后把吃瓜文分享给你的微信好友，在这个过程当中其实就已经发生了进程之间的通信了，本来吃瓜文的链接是在微博这的，然后用微博的分享功能直接就把吃瓜文的链接分享到了微信这，所以这个过程显然是进程和进程之间发生了数据交互也就发生了通信
* 既然进程之间的通信是很有必要的。 那么，进程之间的通信应该如何实现呢？这个需要操作系统的支持，为了探究这个问题， 首先要聊清楚为什么这个进程之间的通信一定要有操作系统内核的支持。

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121647011.png" alt="image-20230512164749915" style="zoom: 50%;" />

* 原因是这样的，系统当中给各个进程分配内存地址空间的时候，各个进程的内存地址空间是相互独立的。 比如进程P可以访问自己的空间，进程Q可以访问自己的空间，但是进程P不可以访问进程Q的地址空间。 这么规定是出于安全的考虑，因为你想一下如果一个进程可以随意地访问其他进程的内存地址空间。那么，一个进程就可以随意修改其他进程的数据了或者随意地读取其他进程的数据。这样的话，想一下你的手机里边不知道什么时候安装了一个垃圾软件，然后这个垃圾软件如果可以随意地访问你的其他进程的地址空间，有可能他直接把你微信里的一些私密的聊天数据或者一些私密的照片之类的直接给你读走了，这显然是很危险的不安全的，因此出于这种安全的考虑，各个进程只能访问自己的这一片内存地址空间，而不能访问其他进程的内存地址空间。 无论是读或者写数据都不行， 因此如果两个进程P和Q，它们之间需要进行数据交互，需要进行进程之间的通信。那么显然，进程P是不可能直接把这个数据写到Q的这片空间里边的。 所以由于进程不可以直接访问其他进程的空间，因此就必须要有操作系统的支持才可以完成进程之间的通信。
* 接下来会介绍三种进程之间的通信方式，分别是共享存储、消息传递还有管道通信。



## 共享存储

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121655371.png" alt="image-20230512165548256" style="zoom:50%;" />

* 首先看共享存储这种进程间通信的机制。
* 共享存储的原理是各个进程只能访问自己的这片空间，但是如果操作系统支持共享存储的这种功能的话。 那么一个进程可以申请一片共享存储区。 而这片共享存储区也可以被其他进程所共享，这样的话一个进程P，如果它要给Q传送数据的话，那么P就可以先把数据写到这一片共享存储区里面，因为它对这片区域是有访问权限的。 
* 然后接下来进程Q再从这片区域里边读出数据所以由于共享存储区可以被多个进程所共享。 因此，这些进程之间的数据交换就可以通过这一片被共享的区域来进行。 这就是共享存储的进程间通信方式，比如像Linux操作系统当中，大家可以去上网搜一下如何实现共享存储呢？
* 首先，一个进程比如说进程P和Q，它们想要通信，那么发起通信的进程P，可以使用shm_open这个系统调用来申请一片共享内存区，也就黄色的这片区域
* 接下来进程P和进程Q都需要使用mmap，使用这个系统调用把这一片存储区域映射到自己的虚拟地址空间当中， 现在大家还不知道什么叫虚拟地址空间，等大家学到第三章的时候再回头看这个部分可能会更清晰一些
* 如果用第三章要学习的内容来解释的话，相当于调用了mmap这个函数之后，进程的页表项或者段表项就会增加一项。然后这个页面或者这个段就可以映射到刚才申请的这一篇共享存储区。这样的话各个进程的虚拟地址空间当中都包含了这个共享存储区，他们都可以访问这一片共享存储区，这个部分大家学到第三章之后再回来看，可能会更清晰一些。 
* 总之，只需要简单的加一个页表项或者段表项就可以完成这种共享内存区的映射这个事情了。 另外还需要注意一个问题，如果多个进程都往这片区域写数据的话有可能会导致写冲突，比如进程P，它正在往这一片区域写，那进程Q也往这一片写就有可能导致数据覆盖的问题，所以各个进程之间如果使用共享存储的方式来进行通信的话，需要保证各个进程对共享存储区的访问是互斥的。应该保证他们对这片区域的访问是互斥的，也就是当进程P正在访问这片区域的时候，其他进程就不能访问这片区域。 怎么实现这个互斥的功能呢？操作系统内核会提供一些同步互斥工具，比如说我们在2.3那个部分会学习P、V操作。
* P、V操作就是操作系统会提供的同步互斥的工具，所以各个进程，他们可以用类似于P、V操作这种机制来实现对共享存储区的互斥的访问，具体的大家可以学了2.3那个小节之后再回头来理解这句话。
* 总之各个进程对共享存储区的访问应该是互斥进行的， 这是共享存储。 

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121720535.png" alt="image-20230512172025442" style="zoom:50%;" />

* 刚才说的共享存储的方案是基于存储区的共享就是操作系统给你划定了这么大的一片区域，比如说这一整片是4 KB这么大

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121720300.png" alt="image-20230512172055229" style="zoom:50%;" />

* 这么大的区域当中，几个进程到底要往这个地方写，还是要往这个地方写，或者读的进程你要从这个地方读，还是从另一个地方读，这些都是很很自由的。操作系统只负责把这片区域画给你，但是并不管你怎么使用这片区域，这是基于存储区的共享。 操作系统划分出这片共享区域之后数据到底要怎么存，到底要存在什么位置都是由要通信的这些进程，它们之间来决定的，而不是由操作系统来决定。 所以这种共享方式，它灵活性非常高，是一种高级通信方式，就是传送数据的速度会很快。

* 相比之下，还有一种方式叫做基于数据结构的共享。 比如说操作系统给你们两个进程划定的这片共享区域，它就规定只能存放一个长度为十的数组，大家可以理解为是一个特殊的全局变量。 这个特殊的全局变量可以被各个进程所共享，为什么叫特殊的呢，因为如果我们写代码的时候定义的全局变量其实是局部于一个进程的。 而这个地方所谓特殊的全局变量，是可以被各个进程所共享的，但是当我们定义这个全局变量的时候，比如说我们是定义了一个int型的数组。 int a长度为3`int a[3]`，各个进程来共享这个数据结构这个长度为三的数组的时候，各个进程对这一片共享区域的访问读和写就只能按照这个数据结构所规定的这种格式来进行了，只有三个int型的变量，每一次要么读，要么写一个int型的变量所以可以看到， 如果是基于数据结构的这种共享的话，进程之间通信的自由度就没有那么高，并且这个传送数据的速度也会比较慢， 所以基于数据结构的这种共享方式是一种低级的通信方式。 

* 这就是进程之间通信的第一种方法， 叫做共享存储。 共享存储又可以进一步划分为基于数据结构的共享和基于存储区的共享。 上面这种共享方式灵活性差，速度慢， 下面这种共享方式灵活性高， 速度快。



## 消息传递

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305121730411.png" style="zoom:50%;" />

* 接下来看第二种进程之间的通信方式，叫做消息传递。如果采用这种方式的话，进程之间的数据交换会以格式化的消息为单位。通过操作系统提供的发送和接收这样的两个原语来进行数据交换
* 什么叫格式化的消息呢？所谓格式化的消息，有两个部分组成一个是消息头，一个是消息体。 消息头要写明这个消息，这一整坨消息到底是由谁发送的，到底要发送给谁，然后整个消息的长度是多少等等就是一些概要的信息这是消息头，然后消息体里边，就是具体的一个进程要传送给另一个进程的数据。 
* 消息传递的进程之间通信方式又可以进一步的划分为直接通信方式和间接通信方式。其中，直接通信方式就是发送进程要指明接收进程的ID，系统里的每一个进程都会有一个进程的ID，PID。发送的进程需要指明到底是谁来接收，所以直接通信方式相当于发送进程直接点名，我就是要他接收就这个意思
* 而间接通信方式会通过一个叫做信箱的一个中间实体来进行通信。 所以，间接通信方式又称为信箱通信方式。来看一下这两种消息传递的通信方式的区别。 

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305122058107.png" alt="image-20230512205837005" style="zoom:50%;" />

* 首先看什么是直接通信方式。进程P现在要给进程Q发送一个消息。 那么，在操作系统的内核区域管理着各个进程的PCB，进程控制块。这是由操作系统来管理的数据结构，在各个进程的这个PCB当中包含了一个队列，叫做消息队列。比如说进程Q的PCB当中就包含了一个进程Q的消息队列，也就是其他进程要发送给进程Q、 应该被进程Q接收的这些消息都挂在进程Q的消息队列里面。 
* 看一下，现在故事是这样的，进程P要给进程Q发一个消息，首先进程P需要在自己的D盘，自己的这片地址空间这来完善这个消息的信息，包括消息头，消息体，接下来进程P会使用到刚才说的操作系统提供的发送原语send。用这个原语来指明我的这个message，这个消息是要发送给Q这个进程。 指明了这个消息的接收者，这个发送原语会导致操作系统内核接收到这个消息，并且会把刚才的这个消息挂到进程Q的消息队列里边。 也就是说，这个消息体是从进程P的用户空间被复制到了内核空间
* 接下来，如果进程Q开始运行，进程Q可以使用接收原语receive 来指明现在要接收一个message，接收一个消息，接收谁发来的message呢，是接收P进程发来的message。 所以这个接收原语这需要指明我要接收的这个这个消息是来自于哪个进程，所以进程Q执行这个接收原语之后,操作系统内核会检查进程Q的这些消息队列。看一下这几个消息到底哪个消息是由P发过来的。

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305122109470.png" alt="image-20230512210950358" style="zoom:50%;" />

* 现在找到了由P发过来的消息，那么操作系统内核会把这个消息体的数据又从操作系统的内核区给复制到给这个进程Q的用户区，地址空间这儿。
* 所以所谓的直接通信方式就是要点名道姓的来进行这个消息传递。一个进程到底是要传给谁，然后接收的这个进程，它接收的时候要接收的是来自于谁的那个消息，需要点名道姓的进行消息传递，这是直接通信方式。

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305122110803.png" alt="image-20230512211049633" style="zoom:50%;" />

## 间接通信方式

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305122111862.png" alt="image-20230512211148741" style="zoom:50%;" />

* 接下来我们再来看什么叫间接通信方式。刚才我们说间接通信方式需要通过一个中间实体所谓的信箱来进行消息的传递， 所以又称之为信箱通信方式。 

* 这种通信方式是这么来实现的。 比如进程P和进程Q之间要通信，那么进程P可以通过系统调用申请一个邮箱，比如说他可以向操作系统申请一个新的邮箱，这个邮箱的名字叫做A，当然也可以申请多个邮箱，比如说另一个邮箱叫做B，现在这两个进程怎么通信呢？ 进程P首先在自己的地址空间这来完善消息体的内容，在自己的地址空间内来填充消息的内容，就相当于你写这个进程P的代码，你定义了一个变量叫message，然后message到底要等于多少，你给它赋一个值。 这就是所谓的在自己的地址空间内完善消息体的信息，其实就是一个赋值的意思。现在进程P已经给他要发送的这个消息，这个消息体已经赋好值了，进程P可以用发送原语send来指明要发送到哪个信箱，指明要发送到的是A信箱，然后发送的是message这个消息体，间接通信方式是指明了要发送到哪个信箱，要发送到A信箱，并没有指明要发送给哪个进程。 刚才我们说的直接通信方式，直接通信方式是指明了点名道姓的，指明了是要发给Q这个进程的，这是直接通信方式，现在间接通信方式，也就是信箱通信方式，并没有指名道姓的说我要发给Q，只是指明了要发送到A这个邮箱这

* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305142054493.png" alt="image-20230514205451356" style="zoom:50%;" />

* 进程Q使用接收源语的时候，可以指明是要从A这个信箱这儿接收一个message，接收一个消息体，这样的话，信箱A的消息message就会被操作系统复制给进程Q的空间这了，所以这就是使用信箱来完成消息传递的一个过程。

* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305142057221.png" alt="image-20230514205758068" style="zoom:50%;" />

* 通常来说操作系统是可以允许多个进程往同一个信箱里发消息，也允许多个进程从同一个信信箱里receive接收消息。这是消息传递里边的间接通信方式，又叫信箱通信方式。 

* 注意体会和之前直接通信方式的区别，直接通信方式需要点名到姓的指明我是谁，我要发给谁。 

* 接下来看最后一种进程之间的通信方式，叫做管道通信。 

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305142059987.png" alt="image-20230514205954852" style="zoom: 50%;" />

* 管道这个词还是很形象的，就像我们的水管，水管的管道一样，就是写进程可以从水管的一边写入数据，读进程从水管的另一边取走数据。 这个数据的流动只能是单向的，就从左到右或者从右到左，只能是单向的，就像水管当中的水流一样，这个水流的方向只可能是单向的，要么从左到右，要么从右到左，没有见过一个水管里边水流既往右，同时也有往左的水流的，没有见过这样的水管，所以管道通信的这个管道和水管是一样的，可以从一端写入数据，从另一端读出数据，这个数据的流向只能是单向的，而不可以是双向同时进行的。 

* 站在操作系统的层面，这提到的管道是一种特殊的共享文件， 又叫pipe文件。 pipe就是英文的水管的意思，管道的意思。也就是说，如果两个进程它们之间要用管道通信的方式进行进程间通信。 那么，首先，需要通过这个系统调用的方式，就某一个进程， 通过系统调用的方式来申请一个管道文件，操作系统会新建这个管道文件， 这个文件的本质其实就是在内存当中开辟了一个大小固定的内存缓冲区。然后两个进程可以往这个内存缓冲区里边写数据和读数据，但是这个数据的读写是先进先出的。 

* 一个管道，一个管道文件，本质上是一个大小固定的内存区域。 这和我们共享内存的方式就没有什么区别了吗？刚才我们说就是之前我们说共享内存的那种通信方式也是操作系统给两个进程，给两个进程P和Q给他们分配了一片可以被共享访问的内存区，而现在的管道，也是一个大小固定的内存区域。 也是可以被两个进程P和Q来访问的，和我们共享内存有什么区别呢？ 区别在共享内存的这种通信方式当中， 这一片内存区域P和Q想怎么玩就怎么玩，想把数据写在这儿，写在这儿，写在这儿都OK，没有问题，然后你想从这儿读数据， 想从这儿读数据都OK，没问题。 没有任何的限制，很自由，这是共享存储的通信方式，没有任何的限制，但是管道通信的这种方式，相当于是操作系统给两个进程分配了一个内存缓冲区，也就是一个管道文件。现在P可以往这个管道文件里边写数据，然后Q是要从这个管道文件里边读数据。什么叫先进先出的特性呢？可以这么理解。 这个区域大小肯定也是有限的，现在P往里边写，如果它的头部这儿是空的，那么它先往这儿写一个字节，比如说一个字节的数据，然后这儿写了之后再往这儿写，然后再往这儿写，再往这儿写，对于Q来说，它要取走数据的时候，并不是说它想读哪儿就读哪儿，它想取哪儿就取哪儿。它只能先把头部的这些数据给取了，依次的往后取， 就是在共享存储的通信方式里边我可以把我的数据写在中间这儿，直接就写在中间这儿虽然前面有空的，但我直接写在中间这儿或者我直接写在尾部这儿都是OK的，没有任何限制。然后我这个读进程读数据的时候也是一样，我可以直接从中间取数据，或者直接从尾部取数据都是OK的，但是在这个管道通信里边是一个数据流的形式，这个数据如果前边还有空位的话，这个数据肯定是先放在前面这个位置，只有前面填满了，才会继续往后面写数据，而读数据的时候也是一样的，只能先把前边的这些数据读空了，然后才可以读后续的这些数据。所以管道通信和共享内存的通信区别还是很大的，管道通信要求数据的读写一定是先进先出的，就是一个队列或者更准确的讲，我们应该把管道的这一小片内存缓冲区，把它理解为一个循环队列。 现在大家应该都学过数据结构了， 循环队列的话如果说整片区域后半部分满了，后半部分就是P写入数据，然后边的这些位置都写满了， 但是前边这些位置如果空出来的话P就可以往这个循环队列的另外空的这一边继续写入数据。所以这个固定大小的内存缓冲区本质上就是一个循环队列。
  而写进程往里边写数据或者读进程从里边读数据都需要遵循队列的先进先出的规则。 这就是管道的内存缓冲区和刚才提到的共享存储的共享内存区的区别，一个是没有限制的，一个是先进先出这种限制的。 

* 刚才还提过一个点，用管道通信的这种方式，一个管道的数据流向一定是单向的，而不可以是双向的。 所以一个管道只能支持半双工通信也就是在某一段时间内，只能实现单向的传输

* 如果说两个进程，我需要给你传，同时你也需要给我传，两个方向的数据传输都需要同时进行的话，称这种双向同时进行的数据传输，为双工，全双工通信。 全双工通信其实是既往的一个概念，半双工通信指的就是同一时刻，只能支持单向的传输。 但是这个方向的传输结束之后，也可以把传输的方向改过来，但是两个方向的传输不可以同时进行， 这是半双工通信。 而全双工通信指的是两个方向的数据传输都要同时进行

* 所以如果需要两个方向的传输都同时进行的话，这种情况下就需要 向操作系统申请两个管道文件，一个管道文件负责从左往右的数据传输，另一个管道文件负责从右往左的数据传输。 另外各个进程对管道的访问也应该是互斥的进行的，但是，对管道的互斥访问是由操作系统来保证的，不需要由这个进程自己来保证

* 第三点需要注意的是刚才我们说这个管道它是一个大小固定的内存缓冲区，既然大小固定，那么这片缓冲区肯定会被写满，如果写满的话，这个进程就不能继续往里边写数据了，所以如果管道被写满的话，那么写进程应该被阻塞。 它写数据的这个动作应该被阻塞等待， 直到读进程把管道里边的数据取走。 等这个管道有空位了，再把写进程给唤醒，另一个方面，读进程是从内存缓冲区里面读数据的，同样的这个数据有可能会被读空，所以如果管道被读空的话， 那么读进程，读read这个动作就应该被阻塞，直到写进程，往这个管道里边写入数据，才可以把这个读进程给唤醒。 所以，管道通信的这种方式，不管是读进程还是写进程，都有可能进入阻塞的状态。 

* 第五点也是管道通信这个部分，很多教材最有争议的一个点。 管道通信的实现方式决定了管道当中的这些数据， 一旦被读出就彻底的消失了，所以如果说有多个读进程，同时读一个管道的时候，就有可能会导致错乱、导致混乱，因为管道里边的这些数据并没有指明说我到底是要给进程Q的，还是要给进程M的没有说明，所以如果多个进程都从同一个管道这读数据的话那么有可能数据的读取这个动作会比较乱。 第一块数据可能被M读走了，然后第二块数据可能被Q读走了，针对这个问题不同的操作系统会有不同的解决方案。 比如说像早期的system 5这种操作系统，它在实现管道的时候就规定一个管道允许多个写进程，多个进程同时往管道里边写，写就完了，但是读进程只允许有一个，不允许多个读进程，同时读管道。2014年的有个408真题当中，高等教育出版社的官方答案也是这么说的， 一个管道可以有多个写进程，—个读进程。这是高等教育出版社官方给的答案。 但是在有的操作系统当中，比如说Linux里边又允许有多个写进程和多个读进程，只不过系统会让各个读进程轮流的从管道当中读数据， 比如说有两个进程Q和M进程都需要从这个管道里面读数据，那么Q和M就是轮流着读的。 你读一次，我读一次，你读一次，我读一次，由操作系统来控制轮流读数据的过程，所以在很多操作系统的教材里边，大家又有可能会看到说一个管道可以被多个进程写多个进程读。而在有的操作系统教材里边，它又会说一个管道允许多个进程写， 但是只允许一个进程读。 因此，这个地方也是去年和前年争议非常非常大，很多同学都不知道该信谁的一个地方。 因此这个地方我们要知道，在实际应用当中，一个管道是可以被允许多个写进程，多个读进程的。 但是毕竟最终是要面对考试。而考试呢这种应试类的考试肯定都得有一个所谓的标准答案，以后大家在讨论管道通信的时候都和这个高教社14年的这些真题统一， 就说可以有多个写进程，然后只能有一个读进程，我们以这种说法为准。 同时，大家在做题的时候，如果看到有的题目说一个管道可以有多个写进程，多个读进程，也不要觉得奇怪。 从现实应用的角度来看，这种说法并没有什么错误。这就是最后一种进程间通信的方式管道通信



## 知识回顾与重要考点

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305142135282.png" alt="image-20230514213526146" style="zoom:67%;" />

* 在这个小节中，介绍了共享存储、消息传递和管道通信这三种常见的进程间通信方式。 这三种通信的功能都是需要操作系统的底层来支持的，共享存储的这种通信方式意味着操作系统会分配一个共享内存区域并且把这个共享内存映射到各个进程的虚拟地址空间当中，这个地方现在大家还暂时看不懂，等我们学到第三章。 知道什么是段表，什么是页表之后再回来看这块，你就会恍然大悟了。 要把一片內存区域映射到进程的虛拟地址空间当中，只需要加一个段表项就可以做到。非常简单，另外，采用共享存储的时候需要注意各个进程需要保证他们是互斥的访问共享空间的，而这个互斥的过程需要由各个通信的进程自己来负责实现，比如说使用操作系统提供的P、V操作等等，就是使用操作系统的同步互斥的机制来确保各个进程是互斥的访问这片区域的，其实本质上对于共享存储区的访问是一个读者，写者问题。 这个是我们在2.3那个小节里边会学的一个经典的同步互斥问题，读者，写者问题，也就是说多个进程可以同时从这片区域里读，但是不可以同时往这片区域里边写。 等大家学到读者写者这个问题的时候，会知道这儿说的是怎么回事

* 接下来第二种进程间通信的方式， 叫做消息传递。 消息传递又可以进一步分为直接通信和间接通信方式。 直接通信方式就是要指名道姓的说明，我要把这个消息发送给哪个进程。然后操作系统会把这个消息直接挂到接收进程的消息队列里边， 这是直接通信方式。 间接通信方式，又叫信箱通信，消息会被操作系统先放到一个指定的信箱当中，而消息的接收者也需要指明自己要从哪个信箱当中取走一个消息

* 这个小节的最后又介绍了管道通信，对于操作系统而言，管道通信的管道其实是一个特殊的共享文件。在Linux里边采用管道通信的话，是可以在自己的系统里边找到这个文件的。 但本质上，这个文件就是一个内存缓冲区。 如果结合数据结构的知识来看的话，这个内存缓冲区其实就是一个循环队列，写进程可以往这个循环队列里边写一些数据，然后当这个内存缓冲区，这个循环队列满了之后，写进程需要阻塞，读进程读的时候，也是一样的， 如果说整个内存缓冲区，或者说循环队列被读空了，那么读进程就需要阻塞等待。 需要注意的是， 一个管道文件只能实现半双工的通信， 这就类似于现实生活中的一根水管可以让水从左往右流，然后也可以让水从右往左流， 但是不可能让这个水管里面的水既往左流也往右流， 所以如果想要从左往右和从右往左的这个水流同时都存在的话，那么就需要建立两个管道，两个水管才可以实现。

* 这就是进程间通信的三种方式

  

* 最后再跟大家说一个王道书上的小问题。 

  <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305142146022.png" alt="image-20230514214624879" style="zoom:67%;" />

* 这个小问题也是去年和前年让无数人抓狂，不知道他说的对不对的一个地方。今年我查阅了大量的资料，并且自己也在Linux操作系统上就是做了管道通信的实验。现在有
  一个很笃定的答案，可以告诉大家王道书里有这样的一句话就是说写进程会先把管道缓冲区给写满，然后才让读进程读。当缓冲区中还有数据时，写进程不会往缓冲区里边写数据，这句话是错误的。这句话读起来就像是说一个管道必须全部写满了之后读进程才可以把管道里的数据取走。 但事实上不是这样的，我在Linux上面做了实验，验证了这个问题。 当我们的写进程往管道里边写数
  据的时候，即便管道没有被写满，也可以被读进程给读走。 就是读进程要读这些数据，只有一个条件，就是管道别空了，只要管道没空，那么读进程就可以继续的从这个管道里面读数据。 对于写进程也是一样的，我不管你这个管道有没有被读空，反正只要
  管道没满，还有空间可以让我写，那么我就可以继续往管道里面写数据。 这是我做实验验证过的东西，所以大家把王道书上的这句话给修改一下，这段话是说的有问题的。 