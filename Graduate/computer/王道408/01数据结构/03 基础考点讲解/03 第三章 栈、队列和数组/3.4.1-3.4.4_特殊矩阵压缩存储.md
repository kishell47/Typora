# 特殊矩阵压缩存储



## 知识总览

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304212059713.png" alt="image-20230421205932565" style="zoom:33%;" />

* 由于矩阵可以很方便的使用数组来存储，所以我们首先会介绍一下一维数组和二维数组背后的一些实现细节。
* 然后会介绍几种特殊矩阵，分别是对称矩阵，三角矩阵，三对角矩阵和稀疏矩阵。这几种矩阵可以用一些简单的策略来节省大量的存储空间。



## 知识回顾与重要考点

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304291308187.png" alt="image-20230429130823077" style="zoom: 50%;" />

* 主要介绍了四种比较特殊的矩阵。可以用什么样的策略来压缩存储，从而节省存储空间

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304291310875.png" alt="image-20230429131026782" style="zoom: 50%;" />



* 这个部分的考题相对来说也比较固定。
* 再次强调题目当中有可能会有这样的一些坑`易错点`



## 一维数组的存储结构

* **C语言定义一维数组**

  * ~~~C
    ElemType a[10];	//ElemType型一维数组
    ~~~

* 一个一维数组当中的各个数据元素，它们的类型都是相同的都是`ElemType`，这样的类型也就意味着每一个数据元素，它们所占的大小空间都是相等的。并且各个数据元素在内存当中是连续存放的，所以我们只需要知道一个一维数组的起始地址，我们就可以很方便的计算出任何一个数组下标所对应的这个元素，它的存放地址是多少，计算的方法就是起始地址`LOC`加上`i`然后乘以每一个元素的大小`sizeof(ElemType)`，注意，我们这儿提到的数组下标，它是从零开始的，而如果数组下标不是从零开始，而是从1开始的话，这个计算方法就得变一下，这儿的`i`就得变成`i- 1`所以大家在做题的时候一定要注意这个题目当中所给的所谓的数组下标，它应该是从0还是从1开始的，如果题目没有特别强调的话，那么就默认是从0开始

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304212114437.png" alt="image-20230421211426284" style="zoom: 50%;" />

  

## 二维数组的存储结构

* C语言定义2行4列的二维数组

  * ~~~C
    ElemType b[2][4];	//2行4列的二维数组
    ~~~

* 同样的二维数组当中的每一个数据元素，它的数据类型都是相同的，也就是说每一个数据元素所需要占的存储空间也都是相同的。

* 那从我们的逻辑视角来看，一个二维数组其实它长的就是这个样子，就是有很多行很多列

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304212121488.png" alt="image-20230421212138426" style="zoom: 50%;" />

* 但是内存当中的这些存储空间，它是连续的线性的。所以当我们把这个二维数组放到内存当中的时候，就需要进行一些变化，有这样的两种存储方法

  * 第一种存储方法叫做行优先，也就是一行一行的存。就是先存第一行，第一行存完了之后，紧接其后，再接着存第二行，这是行优先
    * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304212126365.png" alt="image-20230421212628215" style="zoom: 43%;" />

  * 第二种存放方法是列优先。也就是先存第一列，这是第一列的两个元素，再存第二列，那这是第二列的两个元素那之后的以此类推
    * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304212128043.png" alt="image-20230421212830895" style="zoom:43%;" />

* 就是一列一列的存和一行一行的存，这就是两种不同的存储策略，分别是行优先和列优先，所以我们规定行优先或者规定列优先的存储原则。其实本质的目的是想要把这样的一个非线性的二维数组把它拉成一个线性的形状。因为刚才我们说过，计算机内存的这些存储空间都是线性的

* 把这些数据像这样有规律的存放到内存里边之后，所带来的好处就是可以实现**随机存取**。也就是说，如果我们想要访问二维数组当中的某一个数据元素的话，那我们只需要给出这个元素所对应的行号和列号，那计算机就可以直接算出这个行号和列号所对应的元素，它的存放地址到底是多少

* 如果采用**行优先存储**的话，我们怎么计算某一个元素？它的存储地址呢？

* 我们只需要算出它前面的这些数据元素总共占多少个字节，然后再加上起始地址，那这就是这个元素，它的存放地址

* **==定义一维数组`ElemType b[M][N]; ` 表示定义一个M行N列的一维数组，而元素`b[i][j]`如果数组下标是从0开始的话，那么它所在的位置应该是第`i+1`行第`j+1`列==**

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304212141255.png" alt="image-20230421214133137" style="zoom: 43%;" />

* 要计算`b[i][j]`它的存储地址的话，那首先是要用它的行号`i`乘以**每一行总共有多少个数据元素`N`**然后再加上`j`那这个部分**`i*N+j`计算的结果就是它前面总共有多少个元素**，而每一个元素所占的空间大小又应该是`sizeof(ElemType)`这么多。所以把它们一相乘，这就是`b[i][j]`前面的这些元素所占的空间大小。然后再加上二维数组的起始地址`LOC`，**`LOC+(i*N+j)*sizeof(ElemType)`就是`b[i][j]`的存储地址**

* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304212148461.png" alt="image-20230421214824327" style="zoom:50%;" />
  * 所以只要我们给出一个二维数组的行号和列号，其实计算机就可以立即算出这个元素所对应的存储地址，也就是说二维数组它也具有随机存取的特性。

* 如果采用**列优先存储**二维数组的话，计算的方法也是类似的，我们要找到某一个数据元素它的存放地址。那么我们同样只需要知道，它前面总共存了多少个数据元素就可以了

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304212152203.png" alt="image-20230421215231047" style="zoom:43%;" />

* 所以由于**列优先**的存储方式是一列一列的存的。

* 因此，我们要用**列号`j`乘以每一列总共有多少个元素`M`，然后再加上它的行号`i`,那`j*M+i`这部分得到的结果就是在我们的目标元素`b[i][j]`之前总共有多少个其他的元素，**然后再乘以每一个元素所占的大小`sizeof(ElemType)`那**`(j*M+i)*sizeof(ElemType)`这个部分就是它前面的这些元素所占的总共的大小**

* 然后最后**再加上二维数组的起始地址`LOC`**，**`LOC+(j*M+i)*sizeof(ElemType)`就是`b[i][j]`的存储地址**

  

## 普通矩阵的存储

* 在计算机当中如何存储普通矩阵这种类型的数据？
  * 可以用一个**二维数组来存储矩阵当中的各个元素**
* 当我们在**描述矩阵的时候，它的这些行号和列号都是从1**开始的而我们在描述二维数组的时候，这些下标又通常是从0开始的，这是默认情况。当然，我们在做题的时候，还需要仔细的看一下题目给的条件到底是什么。也有可能矩阵中的这些元素，它的行号和列号也是从0开始的，==**这些都是比较容易错的地方。**==
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304231052490.png" alt="image-20230423105223379" style="zoom: 50%;" />



## 特殊矩阵的存储

* 对于某些特殊的矩阵，可以用一些巧妙的方法来压缩，来节省存储空间。
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304231055858.png" alt="image-20230423105507781" style="zoom: 67%;" />



### 对称矩阵的压缩存储

* **对称矩阵：**
  * 若n阶**方阵**中任意一个元素a~i,j~，都有**a~i,j~=a~j,i~**则该矩阵为**对称矩阵**
    * **是方阵**，也就是说它是有n行n列的，而不是n行m列，就是行数和列数是相同的
    * 对于这个矩阵中的任何一个元素都有`a[i][j]=a[j][i]`
* 它的各个元素的值是关于这条对角线对称的，也就是这条斜对角的区域。
  * **主对角线：**行号等于列号`i=j`
  * **上三角区：**行号小于列号`i<j`
  * **下三角区：**行号大于列号`i>j`
* 可以用一个二维数组来存储这整个矩阵的数据.
  * **普通存储：**n*n二维数组
* 由于对称矩阵的上下三角区的数据其实是完全相同的，因此我们在存储对称矩阵数据的时候，其实我们只需要存储其中的一个部分就可以
* **压缩存储的策略：**
  * 只存储主对角线+下三角区
  * 或者只存储主对角线+上三角区
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304252109343.png" alt="image-20230425210914199" style="zoom: 50%;" />
* **策略：只存储主对角线+下三角区**
  * 按**行优先原则**将各元素存入一维数组中
  * 各个元素在内存中的排列
    * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304231116690.png" alt="image-20230423111610633" style="zoom: 67%;" />
  * 数组大小为`(n+1)*n/2`
    * 一维数组最后一个元素的数组下边为`(n+1)*n/2-1`
  * 站在程序员的角度，对称矩阵压缩存储后怎样才能方便使用？
    * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304252116185.png" alt="image-20230425211637056" style="zoom: 33%;" />
    * 可以实现一个“映射”函数
      * 实现矩阵下标→一维数组下标
    * 站在程序员的角度来看，把一个矩阵的数据存储之后最终的目的其实是想要用这些数据，**当你在用这些数据的时候，肯定是希望从你的视角看到的是一个矩阵，而不是这样的一个一维数组。**也就说你肯定是希望能够从这个矩阵的视角用矩阵的元素下标来访问这些各个元素，而不是直接使用这个一维数组的某个下标。
    * 为了实现这个目的，很简单的一个方法就是你可以**==自己实现一个映射函数==**，这样的话，当你想要访问矩阵中的某一行某一列这个元素的时候。只需要用映射函数一转，就可以知道它存放在这个数组里边的哪个位置，所以这是把对称矩阵压缩存储之后，我们需要实现的很重要的一个东西。**==也是考研当中最喜欢考察的一个点==**。
  * **怎么把矩阵的行号和列号映射为与之对应的数组下标。**
    * 矩阵下标→一维数组下标
      * a~i,j~(i≥j)→B[k]
        * **key:**
          * **按行优先**的原则，a~i,j~是第几个元素?
            * `[1+2+……+(i-1)]+j`→第`i(i-1)/2+j`个元素→数组下标k=`i(i-1)/2+j-1`（数组下标从0开始）
      * 再次强调，有的题目它的**数组下标是从1开始的**，如果是那样的话，就不需要再减这个1，所以这些题目里的细节一定要注意，不要出错。
      * 刚才我们只是探讨了`i≥j`的这种情况，因为`i≥j`这个区域的所有的这些元素都是按照行优先的顺序依次存到我们的一维数组当中的。所以我们可以直接用这种方式就可以找到每一个元素它在数组当中的实际位置
      * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304252153607.png" alt="image-20230425215313474" style="zoom: 33%;" />
    * 如果要访问的是上三角区的这些元素，也就是`i<j`的情况这部分的元素，虽然我们没有把它实际存到这一维数组当中，但是由于对称矩阵，它拥有a~i,j~=a~j,i~的特性。
    * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304252159920.png" alt="image-20230425215917787" style="zoom: 50%;" />
    * 所以其实如果行号小于列号`i<j`的时候我们可以把它转换成访问对应的a~j,i~。这样的话又变成了行号大于列号`j>i`的情况
    * 所以就可以用和刚才相同的方法来算出a~j，i~它的实际存放位置
    * **总结：**
      * 如果**按行优先**的方式来压缩存储对称矩阵，并且我们存储的是主对角线和下三角区，也就是橙色的这个区域的话。那么，我们要把矩阵下标转换成一维数组的下标`k`
      * **转换的规则是：**
        * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304252213035.png" alt="image-20230425221344898" style="zoom: 50%;" />
      * 这东西不要记，应该是能够在考场上临时推出来的东西，实际的考试肯定不会考这样的原题，他肯定会改一些某一些细微的条件。
      * 比如说如果它**告诉你这个对称矩阵存储主对角线和下三角区但是按照列优先的原则来存储个元素**的话，这种情况怎么把矩阵下标转换成一维教组的下标呢？
        * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304261309955.png" alt="image-20230426130938800" style="zoom: 50%;" />
        * 其实思路是一样的，我们只需要算出a~i，j~，它是第几个元素就可以。
        * 那由于是按列优先的方式存储的，所以在a~i,j~第`j`列之前应该是有1到`j- 1`列
        * 而第`1`列总共有`n`个元素
        * 第`2`列有`n- 1`个元素
        * 把每一列的元素都给加起来，那就是一个等差数列求和，`n+(n-1)+……+(n-j+2)`计算出来的就是第`j`列之前总共有多少个元素
        * 另外用行号`i-j`就是在同一列当中这个元素之前还有多少个元素
        * 这个地方我们讨论的是a~i，j~，它到底是第几个元素，所以我们还需要再加1，
        * 所以a~i,j~是第`[n+(n-1)+……+(n-j+2)]+(i-j)+1`个元素
        * 知道它是第几个元素之后，我们只需要再确定一下这个数组下标到底是从0开始还是从1开始那转换成数组下标就很简单了。
        * 那这是一种出题方法，除此之外，`它是不是还可以存储主对角线`，加上三角区，但是做题方法都很简单
        * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304272111867.png" alt="image-20230427211148785" style="zoom:50%;" />



### 三角矩阵的压缩存储

* 三角矩阵，三角矩阵可以分为下三角矩阵和上三角矩阵。

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304272131272.png" alt="image-20230427213108093" style="zoom: 50%;" />

  * **下三角矩阵：**除了主对角线和下三角区，其余的元素都相同

  * **上三角矩阵：**除了主对角线和上三角区，其余元素都相同

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304272137444.png" alt="image-20230427213714263" style="zoom: 33%;" />

  * 由于这一整块区域所有的这些数据元素，它们的值都是相同的，所以其实我们并不需要重复的存放这么多份数据。也就是说，我们只需要重点存储，不是常量的这个部分，这些数据的压缩存储方法和刚才对称矩阵是一样的

  * 我们可以按照行优先或者列优先的原则，把不是常量的这些区域都放到一个一维数组里边。

    * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304272143310.png" alt="image-20230427214333153" style="zoom: 50%;" />

  * 这个一维数组的长度是`1+2+……+n`

  * 除了存储这个区域之外，我们还需要再增加一个位置用来存放这个常量的值。所以整个一维数组的长度就应该是`n(n+1)/2+1`，相比于对称矩阵来说，存储同阶的三角矩阵，我们需要多一个存储单元

    接下来问题和对称矩阵也是一样的，我们存这个矩阵的目的，其实是为了用这个矩阵，而用这个矩阵，我们就需要把行号和列号把它映射为与之对应的数组下标。

  * 计算方法和对称矩阵一样，式子都是一样的，唯一不同的是，如果我们此次要访问的是上三角区也就是。行号小于列号`i<j`的这个区域的话。那这个区域所有的元素，它们都是一个常量c，因此访问这个区域的任何一个元素。我们都应该把它映射到这个一维数组的最后一个位置，所以上三角区的这些元素它所对应的一维数组下标就应该是`n(n+1)/2`。

  * 这儿我们探讨的是下三角矩阵的压缩存储，上三角矩阵也是类似的

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304272151197.png" alt="image-20230427215153996" style="zoom: 50%;" />

  * 要把行号列号映射为所对应的数组下标，要考虑的其实就是这个元素，它到底是第几个元素

    * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304272154389.png" alt="image-20230427215449247" style="zoom:50%;" />

  * 按照行优先这样的一个原则，那第`i`行之前应该是有第`1`行到第`i-1`行这么多的元素，第`1`行总共有`n`个，第`2`行总共有`n-1`个，以此类推，第`i-1`行就应该是`n-i+2`这么多个元素

  * 所以第`1`行到第`i-1`行总共就应该有`n+(n-1)+(n-2)+……+(n-i+2)`个元素，这是一个简单的等差数列求和

  * 除了前面这几行之外，在第`i`行，这个元素之前应该还有`j-i`个元素，所以a~i,j~前面总共应该有`n+(n-1)+(n-2)+……+(n-i+2)+(j-i)`个元素，所以a~i,j~对应的数组下标就应该是`n+(n-1)+(n-2)+……+(n-i+2)+(j-i)`那计算结果就应该是这样的

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304272206352.png" alt="image-20230427220618279" style="zoom:50%;" />

  * 这是`i≤j`的情况，如果要访问的是下三角区的话，那我们需要直接把它映射给这个数组的最后一个位置，也就映射到常量存储的这个位置

    

### 三对角矩阵的压缩存储

* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304272211953.png" alt="image-20230427221155798" style="zoom: 50%;" />
* 三对角矩阵又称为带状矩阵
* 这种矩阵的特点就是，行号和列号的绝对值相差大于1，`|i-j|>1`的时候，只要满足这个条件，那这些元素的值都为0。
* 如果形象一些理解的话，我们先来看中间这一条，也就是主对角线，主对角线的这些元素。`i=j`，也就是`|i-j|=0`
* 从这个主对角线往右走一格的话`|i-j|=1`，这个元素可以不为零，而如果再往右走一格的话，`|i-j|=2`，所以这个元素再往右肯定是一个0元素。
* 往左也一样，从主对角线元素往左一格这个元素，`|i-j|=1`，所以它可以不为零。再往左一格，`|i-j|=2`，所以这个元素肯定是0
* 上下的关系也一样的，从这些主对角线元素往上一格，`|i-j|=1`，所以它可以非零。再往上格`|i-j|=2`所以这个元素肯定是0元素
* 因此如果直观一点来理解的话，所谓的带状矩阵或者三对角矩阵就是指所有在主对角线上的元素可以是非零元素，另外从主对角线元素出发，它们的上下左右与它们相邻的这几个元素也可以是非零元素。再往外的这些元素就肯定是零元素
* 基于这个特点，我们其实只需要存储带状矩阵的这些非零元素就可以了。思想都是类似的，比如我们可以按照这样行优先的原则，一行一行的存储这些非零元素。把它们依次存放到一个一维数组当中，对于带状矩阵来说，除了第一行和最后一行只有两个元素之外，其他每一行肯定都有三个元素。
* 所以一个n阶的带状矩阵，我们需要存储的元素个数就应该是它总共有n行，每一行有三个元素然后再减掉第一行，少了一个，最后一行少了一个，也就是减掉二。它总共需要存储`3n-2`个元素，因此这个一维数组的长度就应该是`3n-2`，由于我们默认数组下标从零开始，因此最后一个元素，它的数组下标就应该是`3n-3`。
* 接下来要解决的问题就是，怎么把行号列号把它映射为与之对应的数组下标，如果要访问的这个元素它的行号和列号差值大于一的话。那么这个区域的元素肯定就是零，这些元素的值不需要来数组里面找，
* 所以只探讨`i`和`j`的差值小于等于一的情况。
* 这个范围内的元素才是存放在数组当中的，思路和之前是类似的，只需要看a~i,j~这个元素，它按照行优先的规则，到底是第几个元素就可以了，每一行都会有三个元素，然后再减掉第一行，还少了一个元素。所以前面的`i- 1`行应该有`3(i-1)-1`，
* 另外不难发现a~i,j~应该是第`i`行的第`j-i+2`个元素
* 所以整体来看a~i，j~应该是第`2i+j-2`个元素，如果数组下标是从0开始的，那么转换成`k`的话，就还需要在`2i+j-2`上再减一，那这样的话，我们就用行号和列号映射到了与之对应的数组下标
* 接下来，如果反过来考虑，假设我们已经知道数组下标`k`怎么得到与之对应的行号和列号呢
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304282118265.png" alt="image-20230428211846079" style="zoom: 50%;" />
* 显然，由于`B[k]`元素，它是第`k+1`个元素，所以`k+1`肯定要大于`3(i-1)-1`,因为`3(i-1)-1`是`B[k]`前面的`i- 1`行的元素个数，`k+1`又要刚好小于等于`3i-1`，因为前`i`行总共应该是`3i-1`这么多个元素。
* `k+1≤3i-1`这个不等式，把它解出来应该是`i≥(k+2)/3`，那怎么`i`的值刚好大于等于`(k+2)/3`呢？其实只需要向上取整就可以`i=⌈(k+2)/3`⌉
* 因为我们这算的`i`是行号，所以它肯定是一个整数，因此当`i`取得`⌈(k+2)/3⌉`的时候，就刚好可以满足`k+1≤3i-1`这个不等式。也就可以保证我们这儿要找的这个元素`B[k]`，刚好就是在第`i`行
* 王道书上给的`i`值的计算方法看起来不一样。但是其实计算的结果和我们上面这儿推出的这式子是完全一样的，大家可以自己带进去验证一下。
* 这个式子的k值，我们可以把它理解为我们要找的这个元素也就是第`k+1`个元素，前面总共有`k`个元素，那`k`的值就应该是小于`3i-1`，然后大于等于`3(i-1)-1`
* 类似的这个地方的小于等于我们要把它理解为我们最终取得的I值。要刚好让这个小于等于能够得到满足，所以在解出不等式`3(i-1)-1≤k`之后，我们只需要对`(k+1)/3+1`向下取整。
* 就可以得到，刚好能够满足这个不等式的值`i=⌊(k+1)/3+1⌋`
* `i=⌊(k+1)/3+1⌋`和`i=⌈(k+2)/3`⌉是等价的。
* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304291218580.png" alt="image-20230429121820459" style="zoom: 43%;" />
* 算得`i`值之后，由于`k,i,j`之间有`k=2i+j-3`的关系，接下来我们就可以用`k`和`i`推出`j`的值`j=k-2i+3`。
* 所以用这样的方法，我们就可以从数组下标`k`得到这个元素所对应的行号和列号`i,j`
  * `i=⌊(k+1)/3+1⌋`或`i=⌈(k+2)/3`⌉
  * `j=k-2i+3`
* 注意体会，这个地方怎么来处理不等式当中刚好大于
  等于（向上取整`⌈⌉`）或者刚好小于等于（向下取整`⌊⌋`）这样的一个问题。



## 稀疏矩阵的压缩存储

* **稀疏矩阵**就是指非零元素的个数远远少于矩阵
  元素的个数

* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304291230135.png" alt="image-20230429123051043" style="zoom: 50%;" />

* 这整个矩阵当中，非零元素只有这么几个，寥
  寥无几。当然，什么叫远远少于这个，并没有一个
  固定的界限。

* 反正作为程序员，大家应该对稀疏这个词都有一个很深刻的理解，摸摸自己的头顶就知道了。

* 那对于这样的一个稀疏矩阵，如果我们定义一个和它尺寸相当的二维数组，那是不是会感觉这二维数组里边很多空间都是没有必要的，因为存的都是零。所以我们可以用一些技巧把它所需要的存储空间给压缩一下

* 第一种方法，可以用顺序存储的方式来存储一系列的三元组。每一个三元组由行号，列号还有所对应的值构成，在这里边存储的都是稀疏矩阵里边的非零元素。

* 这样的三元组怎么顺序存储呢？

  * 可以定义一个`struct`这`struct`里边有`i`有`j`。有`value`。
    * 也就是一个`struct`里面，有这样的三个字段
    * 也就是一个`struct`对应这儿的一行
    * 再定义一个和这个`struct`相对应的一维数组
      就可以顺序的存储这些三元组了
    * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304291244872.png" alt="image-20230429124435784" style="zoom:50%;" />

* 这是稀疏矩阵的第一种压缩存储的方法，显然用这种方式存储稀疏矩阵的话，那你要访问其中的某一个元素
  只能顺序的依次扫描，这些三元组会失去随机存取的特性

* 这是第一种方法，可以用这样的一个一个三元组来分别表示各个非零元素

* 第二种方法叫做十字链表法，怎么存呢？

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304291303698.png" alt="image-20230429130353502" style="zoom: 50%;" />

* 一图甚千言。可以定义这样的一个数组，这个数组里边存放的是一个一个的指针，我们把这些指针称之为向
  下域。这儿的每一个指针，其实就对应了稀疏矩阵当中的每一列

* 然后这边我们同样需要定义一个指针数组。这些指针分别对应稀场矩阵当中的各行每一个非零元素，会对应这样的一个节点。

* 这个节点当中包含了非零元素所在的行列是多少，然后它的值是多少

* 另外还会有两个指针。

* 来看一下这个稀疏矩阵第一行的第一个非零元素是四，那么，第一个向右域这个指针，它所指向的结点对应的就是`1,3,4`是第一行第三列，然后值是四

* 然后结点的绿色指针会指向同一行的下一个数据元素，那第一行的下一个非0元素应该是5，所以这个指针就指向了5这个节点，而5这个节点它是在第1行第6列。

* 那其他各行的结点也是类似的，那向下域其实原理也是相同的.

* 比如说第二列，从上往下看，第1个结点应该是3。那么2这个向下域它所指向的第一个结点应该是3这个结点，而这个结点它所对应的元素应该是在第2行第2列，所以这儿是2,2。然后这个数据结点的这个指针，它又会指向同一列的下一个非0元素。第2列的下一个非0元素应该是2，它应该在第4行第2列，所以应该是4，2，然后值是2。

* 那结合这两个图应该不难理解什么是十字链表法

  