# 栈的应用——表达式求值（2）



## 知识总览

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304171459812.png" alt="image-20230417145938721" style="zoom:33%;" />

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304202121242.png" alt="image-20230420212135085" style="zoom:43%;" />



## 中缀表达式转后缀表达式（手算）

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304171655141.png" alt="image-20230417165535990" style="zoom: 50%;" />



## 中缀表达式转后缀表达式（机算）

* **例1——不带界限符（）**
  
  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304171702454.png" alt="image-20230417170202377" style="zoom: 40%;" />
  
* **算法的整体方法**
  
  * 初始化一个**栈**，用于**保存暂时还不能确定运算顺序的运算符**
    * 把**中缀表达式转换成后缀表达式**的时候。中缀表达式当中，这些操作数的出现顺序是abcdef，然后后缀表达式里边也是abcdef，所以其实这些**操作数的相对顺序是不会改变的。**
    * 而这些**运算符之间相对的先后顺序是会改变的**，所以我们会用一个**栈来存储当前暂时还不能确定运算顺序的运算符**
    
  * **从左到右**处理各个元素，直到**末尾**。可能遇到三种情况
    
    * 遇到**操作数**。直接加入**后缀表达式**
    
    * 遇到**界限符**。
      * **遇到“(”直接入栈**；
      * **遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(”为止。**
      * **注意：“(”不加入后缀表达式**
      
    * 遇到**运算符**。
      
      * 依次弹出栈中**优先级**高于或等于当前运算符的所有运算符，并加入后缀表达式
        * 运算符的优先级：*/优先级高于+-
      
      * 若碰到“(”或栈空则停止，之后再把当前运算符入栈
    
  * 按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式

* **算法背后的逻辑**

  * 中缀表达式中，若出现操作数的话，那么这个操作数的左右两边肯定都会有运算符，除了第一个和最后一个之外.

  * 我们在处理中缀表达式的时候是从左往右依次扫描的，所以之前这个栈里本来放了一个加号。
    
  * 然后在这个加号的后面紧接着就扫描到了一个减号，可以说明其实减号和加号中间肯定是夹住了某一个操作数
    
  * 所以扫到减号的时候，我们就可以确定他们中间夹住的这个操作数，它既要进行加法运算，也要进行减法运算。
    
  * 而由于这两个运算，它们的优先级都是相等的。
    
  * 那么，根据左优先的原则。
    
  * 其实我们可以让这个操作数先执行，它左边这个运算符所对应的运算。
    
  * 所以我们就可以把加号先弹出栈，
    
  * 因为后缀表达式当中各个运算符出现的先后顺序，其实就是它们生效的先后顺序，所以先弹出加号就意味着可以先让加法先生效。
    
  * 加法已经生效了，那其实我们在中缀表达式当中就相当于，接下来需要把这个a+b看作是一个整体
    

* 继续往后扫描c是一个操作数，可以直接输出，然后再往后扫描到一个乘号，经过检查发现，此时栈顶的元素是一个减法。这也就意味着，当前扫描到的这个乘法，它左边的操作数的前面这个运算符是一个减法运算。先乘除后加减，所以就不能把这个减号给弹出栈，因为这个减号弹出栈之后就意味着减号是比乘号先生效，但这不符合运算的规则，那既然不能先算减法，那可不可以先直接就把这个乘法给弹出，先算这个乘法呢？
* 显然也是不行的，为什么呢?因为如果这个乘法后面刚好出现了一个括号，那是不是这个乘法它的运算顺序也得往后靠一靠？所以当我们扫到这个乘号的时候，由于我们也暂时不能确定能不能先运行这个乘法，因此我们也需要把它先压入栈中
* 继续往后是一个操作数，可以直接把它输出，又往后扫描到的是一个除号，那是不是原理类似，我们检查这个栈顶元素，发现它是一个乘法。
* 那就意味着这个除号左边的操作数再左边的这个运算符
  它是一个乘号。那当这个操作数既需要乘，也需要除的时候，那由于乘法和除法，它们的优先级都是相等的，那我们是不是可以先让左边的这个乘法先生效啊？
* 而乘法生效之后，我们就需要把`C*D`看作是个整体，这个加号也生效了，所以也需要把`A+B`看成一个整体。那现在再检查这个栈顶元素，它是一个减法，那是不是就说明这个除号左边的这个操作数，它再左边的运算符是一个减法运算符？那虽然除法的优先级比减法更高，但是由于我们并不能确定这个除号后面有没有跟小括号，所以扫描到这儿的时候，我们也不能确定这个除法到底可不可以先生效。所以我们还需要把这个除号给压入栈里边，那继续往后是一个操作数，可以直接输出，再往后是一个加号。那检查这个栈顶元素，发现是一个除法，那就意味着这个加号左边的操作数。它的再左边一个运算符是个除法运算符，那这个数既需要除也需要加，那显然到这儿我们就可以确定，应该让这个数的除法先生效。所以我们就可以大胆的把优先级更高的这个除号给弹出来，那弹出除号就意味着除法已经生效了，那我们接下来是不是需要把前面的`C*D/E`看成一个整体
* 接下来我们再看这个栈顶元素。同样的逻辑，这就意味着加号前面的`C*D/E`，它的左边一个运算符是一个减法运算符，而当这个操作数既需要减也需要加的时候，按照左优先的原则，我们可以先让它左边的这个减法先生效，因此我们也可以把
  这个减号给弹出栈，加到后缀表达式当中。
* 接下来是最后一个操作数，可以直接输出所有的字符都处理完了之后，我们还需要把栈里边剩余的运算符依次弹出。那只剩下一个加法把它弹出，所以这就得到了我们的后缀表达式和我们手算的，这种结果是一样的。





* **例2——带界限符**

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304201919299.png" alt="image-20230420191931215" style="zoom: 25%;" />

  * **算法背后的逻辑**
    * 如果此时栈顶刚好就是左括号的话，那么我们不需要弹出任何元素的，我们可以直接把当前的运算符入栈。也就是把减号压进去。想一下背后
      逻辑，我们扫到这个减号的时候，如果栈顶是一个左括号的话那么就说明减号左边的操作数。它的旁边会有一个左括号。
    * 虽然说我们要优先计算括号里边的这些运算，但是由于扫描到这个地方的时候，我们并不能确定后面的这个操作数。它的旁边有没有可能跟个乘法，也就是说我们此时不可以确定这个减法可不可以立即生效？而确定不了运算顺序的这些运算符，我们都需要先把它压到栈里，所以我们并不需要弹出任何的元素，可以直接把这个减号给
      压到栈顶。
    * 继续往后操作数，直接输出再往后会遇到一个右括号，当我们遇到右括号的时候，我们需要依次弹出这个栈里边的运算符。直到弹出左括号为止，所以先弹出减号，然后再弹出左括号，但是左括号是不需要加到后缀表达式里的因为后缀表达式是没有界限符的。好，再想一下背后的逻辑，扫到右括号的时候，是不是我们已经可以确定这整个括号的范围了？那由于需要优先计算括号内的内容，所以我们就可以大胆的，先把括号
      里边的这些运算符全部弹出就意味着这括号里边的所有运算都可以先生效。
    * 再往后是一个减号，那根据这条规则，乘号优先级比它更高，然后加号优先级和它相等，所以我们先要把这两个运算符先弹出。
    * 然后再把减号压到栈里边。背后的逻辑就不再重复好，继续往后是一个操作数直接输出，再往后是一个除法。那由于除法的优先级要比栈顶的减号优先级更高。所以可以直接把它入栈。再往后操作数直接输出，到此为止，我们就处理完了所有字符接下来就可以依次把栈里边的这些运算符给弹出然后加到后缀表达式当中，那这样的话，我们就完成了用栈实现的后缀表达式的转换。

* **例3**

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304201957297.png" alt="image-20230420195707236" style="zoom: 50%;" />



## 中缀表达式的计算（用栈实现）

* **用栈实现中缀表达式的计算:**
  * 初始化两个栈，操作数栈和运算符栈
  * 若扫描到操作数，压入操作数栈
  * 若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）
* **用栈实现后缀表达式的计算**
  * ①从左往右扫描下一个元素，直到处理完所有元素
  * 若扫描到操作数则压入栈，并回到①；否则执行③
  * ③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①
    * 先弹出的是右操作数
  * 栈是用来存放当前还不能确定运算次序的操作数.
* **中缀转后缀**
  * 栈是用来存放当前还不能确定生效次序的运算符
* **中缀表达式的计算（用栈实现）：**
  * 中缀转后缀
  * 后缀表达式求值
  * 两个算法的结合.
* 在中缀转后缀这个算法当中，我们从左往右扫描的时候，是不是就可以从左往右的依次的挨个的输出这个后缀表达式的某些部分了？
* 而后缀表达式求值的这个过程，是不是也是从左往右扫描这个后缀表达式的？所以其实可以把这两个算法给
  结合。
* 我们一边生成这个后缀表达式，一边就用后缀表达式的计算逻辑来计算后缀表达式前半部分的该些值。
* 所以用栈实现中缀表达式的求值，其实就是之前两个算法的结合



* **例1**

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304202048336.png" alt="image-20230420204835290" style="zoom: 50%;" />

  * 从左往右扫描这个中缀表达式，当我们扫描到操作数的时候，就直接压到操作数栈里边。所以刚开始扫到`A`，直接放到栈里，接下来扫到的是一个运算符，那扫到运算符或者界限符的时候，我们要按照中缀转后缀那边介绍的逻辑。来判断是不是应该把它压到栈里，或者说是不是应该弹出这个栈里的某一些运算符？由于此时栈是空的，那我们可以直接把加号压进去，再往后扫描到一个操作数，同样的把它放到操作数站里边。接下来扫描到一个运算符减号，那按照之前中缀转后缀的这个逻辑，由于此时栈顶的加号和减号，它们的优先级是相等的。因此，我们需要把这个加号弹出栈.
  * 一个运算符，把它弹出栈，其实就意味着这个运算符已经确定，可以先让它生效了。所以在我们弹出一个运算符的时候，就需要再弹出这个栈里的两个操作数。让这两个操作数执行相应的运算，然后把运算的结果再压回操作数栈里边，那这个处理是不是和后缀表达式求值是一样的，我们先弹出的这个元素`B`，他是右操作数。而后弹出的元素`A`，它是左操作数。
  * 好，那接下来还需要把当前扫描到的这个减号给压到栈里，接下来是一个操作数，直接入栈，再往后是一个乘号，那由于乘号的优先级比这个减号高，所以我们不需要弹出减号，可以把乘号压入栈里边，接下来碰到一个操作数,入栈再往后遇到一个除号，那根据中缀转后缀的逻辑，我们需要把乘法。弹出栈和刚才一样，弹出这个运算符的时候，就意味着这个运算符需要生效，那么我们就需要弹出这个栈顶的两个操作数。让他们执行相应的运算，先弹出的是右操作数，所以就应该是`C*D`，那么这个结果还需要再压回栈顶
  * ...
  * 扫描完了所有的东西之后按照中缀转后缀的逻辑，还需要把运算符栈里边的所有的运算符都依次的弹出栈，而每当弹出一个运算符的时候就需要让这个运算符生效.

* **算法思想**
  * 用这个算法的这种思想，其实可以把一个很复杂的
    数学运算把它拆解为一个一个独立的加减乘除运算
    每次都只执行一个基本的运算，也就是加减乘除
  * 等大家学了计算机组成原理之后就会知道，其实我们的CPU是很傻的。CPU只能执行最简单的这些加减乘除运算，并且每次只能执行一个。
  * 所以虽然我们编程的时候可以很简单的写一个算术表达式，但是其实你的这个程序经过编译之后是需要把它翻译成一条一条的CPU，能够执行的基本的指令的，也就是说，需要把这个复杂的式子把它拆解成像刚才我们分析的这样一次一个加法，一次一个减法或者一次一个乘一次一个除。因此，在编译程序当中，把这样的式子翻译成与它等价的机器指令的时候,其实就需要用到我们这儿提到的这种中缀表达式计算的这些思想和方法，它很重要，甚至
    可以说我们写的任何一个程序都需要用到这个算法来处理，只不过代码的编译这些事情，我们平时并接触不到。
  * 对于我们学习的这些内容，除了搞明白HOW就是他是怎么做的之外。其实对WHY的思考甚至比HOW还要更重要。