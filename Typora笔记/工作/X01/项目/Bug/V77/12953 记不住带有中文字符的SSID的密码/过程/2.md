# C++程序是如何执行的

* C++程序的执行是由操作系统控制的。一般情况下，程序是通过编译器编译成可执行文件的形式，并在操作系统上运行。

* 在 **Windows 操作系统**中，**双击可执行文件**将启动一个**进程**，该进程会先执行一些初始化操作，如分配内存、设置栈指针、调用主函数等，然后**开始执行主函数**。在 **Linux 或者 Unix 操作系统**中，**可执行文件被传递给 shell，由 shell 解释执行**。
  * 在 **Linux 或者 Unix 操作系统**中，可执行文件被传递给 shell，是指**将可执行文件作为命令传递给 shell 解释执行**。**Shell 是命令解释器，是用户与操作系统内核之间的一个接口，可以接受用户的命令，解释并执行。**当用户在命令行输入命令时，Shell 会先将命令解释成可执行文件的形式，然后将可执行文件加载到内存中，并执行其指令，最终返回执行结果给用户。因此，可执行文件必须是符合操作系统规范的二进制文件，才能被 shell 加载和执行。

* 在执行过程中，操作系统将**程序加载到内存**中，并**根据程序中的指令依次执行**。程序可以包含多个源文件，编译器会将这些源文件编译成一个可执行文件。在程序执行期间，操作系统会将可执行文件中的指令加载到内存中，并根据程序计数器的指向执行每条指令。

* 当程序调用其他函数或者对象的方法时，操作系统会将程序的执行流程转移到被调用函数或方法的地址，并执行相应的操作。当函数或方法执行完毕后，操作系统会返回到原来的执行流程，继续执行后续的操作。

* 在程序执行结束后，操作系统会将程序所占用的内存等资源回收，以便其他程序或者操作系统本身使用。



# 1 内存分区模型

C++程序在执行时，将内存大方向划分为**4个区域**

- **代码区：**存放函数体的二进制代码，由**操作系统**进行管理的
- **全局区：**存放**全局变量和静态变量以及常量**
- **栈区：**由**编译器自动分配释放, 存放函数的参数值,局部变量**等
- **堆区：**由**程序员分配和释放,若程序员不释放,程序结束时由操作系统回收**



**内存四区意义：**

不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程



## 1.1 程序运行前

* 在程序编译后，生成了exe可执行程序，**未执行该程序前**分为两个区域

* **代码区：**

  * 存放 CPU 执行的机器指令

  * 代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可

  * 代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令

* **全局区：**
  * 全局变量和静态变量存放在此.
  * 全局区还包含了常量区, 字符串常量和其他常量也存放在此.
  * ==该区域的数据在程序结束后由操作系统释放==.



## new操作符

* `new 类名()`

  * 在C++中，使用`new`关键字可以动态分配内存，并返回指向该内存地址的指针。

  * 当我们使用`new`时，**会自动调用该类的构造函数来初始化分配的内存空间。**

  * `new 类名()`的作用是创建一个该类的对象，并返回指向该对象的指针。

  * **例1：**

    * `Intent* in = new Intent();`

      * `in`指向内存中的一片区域，该区域存储的是一个`Intent`类的对象

      * 相当于`in`可以使用`Intent`类的成员变量和成员函数，用指针->的的方式.

      * `new`的时候会自动调用`Intent`类的构造函数来初始化分配的内存空间

        * 即调用

          * ~~~C++
            Intent(int action = E_INTENT_ACTION_MAIN, std::string uri = "") :
            	mAction(action), mUri(uri) { }
            ~~~

          * **类中的成员变量：**

            * `int mAction`:初始化为`action`==`E_INTENT_ACTION_MAIN`=0

              * ~~~C++
                public:
                	typedef enum {
                		E_INTENT_ACTION_MAIN,
                		E_INTENT_ACTION_VIEW,
                		E_INTENT_ACTION_EDIT
                	} EIntentAction;
                ~~~

              * `enum Intent::EIntentAction::E_INTENT_ACTION_MAIN==0`

              * `E_INTENT_ACTION_MAIN`是`Intent`类枚举类型值为0

            * `std::string mUri`:初始化为`""`空字符串.



## `putExtra`函数

* ~~~C++
  in->putExtra(INTENT_WIFI_NAME, ssid);
  /**
   * @brief 设置键值数据
   * @note 统一设置为string类型，如int类型需转为string类型，再存储，getExtra的时候再转一下
   */
  void putExtra(const std::string &key, const std::string &value) {
      mExtras[key] = value;
  }
  ~~~

  * 