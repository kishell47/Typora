# 栈的应用——递归



## 知识总览

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211524922.png" alt="image-20230421152400828" style="zoom: 40%;" />

* 了解函数调用栈的一个原理。在我们看不见的背后，系统是如何通过一个栈来帮你实现你的函数调用这个过程

* **递归算法：**递归函数调用自身
* **递归过程：**函数调用过程



## 函数调用背后的过程

* 一个简单的程序
  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304210856701.png" alt="image-20230421085609619" style="zoom: 60%;" />
  * `main函数`定义了一些局部变量，然后执行前面这些代码。
  * 调用了`func1函数`，然后在这个函数执行到这一
    句的时候又会调用`func2函数`。
  * 等`func2函数`执行结束之后，它又会返回`func1函数`，然后接着执行后面的这些代码。
  * 最后等`func1函数`执行结束之后又会返回`main函数`，然后执行后续的这些代码

* **函数调用的特点：**最后被调用的函数最先执行结束`LIFO`，和栈的`后进先出`一样.
* 在我们的任何一段代码，任何一个程序运行之前，其实系统都会给我们开辟这样的一个**函数调用栈**
  * **==函数调用栈就是内存中的某一片区域，某一片存储空间.==**
  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304210931394.png" alt="image-20230421093122310" style="zoom: 50%;" />
  * **函数调用栈**用来保存各个函数，在调用过程当中必须保存三方面信息：
    * 调用返回地址
    * 实参
    * 局部变量
* **函数调用栈——main函数入栈**
  * 程序的入口就是`main函数`，所以刚开始运行`main函数`的时候，其实会把`main函数`相关的一些必要的信息给压入栈中，比如说`main函数`里边的这些局部变量`a,b,c`，它们的值就是存放在这个位置`main函数调用栈`
    * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304210932687.png" alt="image-20230421093219611" style="zoom: 50%;" />
* **函数调用栈——func1函数入栈**
  * 接下来`main函数`会调用`func1函数`，我们的程序要执行的是`func1函数`所对应的这些代码。那等这些代码执行完了之后，接下来又应该执行哪句代码呢？显然是`c=a+b;`，但是这是肉眼看见的.
  * 计算机解决这个问题的方式就是他会在调用`func1函数`的时候，把`func1函数`执行结束之后应该执行的这句代码的存储地址`#1`压到栈中.
  * 除此之外，函数调用的这两个参数也会放到这个栈里边，也就是`a,b`这两个参数
    * 所以为什么大家在函数调用的时候，如果在`func1函数`里边修改`a`的值或者`b`的值，那么，它修改的其实是内存当中`func1函数`里面`a`和`b`的值，但是`main函数`里边的`a`和`b`这两个变量其实对应的是内存当中的另外两份数据。因此，在`func1函数`里边修改`a`和`b`的值，影响不到`main函数`里边的`a`和`b`
  * 那除了被调用函数的实参之外，这个函数里边定义的局部变量`x`。也是放在这个栈里边的
  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304210944254.png" alt="image-20230421094436107" style="zoom: 45%;" />
* **函数调用栈——func2函数入栈**
  * 接下来`func1函数`一会调用`func2函数`，那同样的，我们应该记录下来`func2函数`执行结束之后，我们应该回到哪一句继续往后执行，就把这一句代码的存放地址也给放到这个栈里边
  * 同时还需要存放实参，还有局部变量这些信息
  * 接下来等`func2函数`执行结束之后，就可以从这个栈顶的信息得知再往后应该执行的是这一句代码，因为我们已经把下一句该执行的代码的地址给记录下来了。
  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211013403.png" alt="image-20230421101359265" style="zoom:45%;" />
* **函数调用栈——func2函数出栈**
  * 那这个函数执行完了之后就可以把和它相关的这些信息给**==弹出栈，也就是说释放了这一片内存空间。==**
  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211017324.png" alt="![](https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211017324.png)" style="zoom: 50%;" />
* **函数调用栈——func1函数出栈**
  * 接下来就从`x=x+10086`继续往后执行,那再往后也是一样的`func1函数`执行结束了之后又可以通过栈顶记录的信息知道再往后应该执行的是`c=a+b;`所以我们就可以把`func1函数`相应的这些信息给删除
  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211021638.png" alt="image-20230421102122508" style="zoom: 50%;" />
* 接着从`c=a+b;`往后执行.
* 所以这其实就是函数调用背后发生的一些事情。其实背后是需要用一个栈来支持的，那从我们的视角来看，程序是从`main函数`开始的，但其实你的程序在经过编译之后，你的编译器其实会在`main函数`之前，还给你加其他的一些代码，然后那些代码执行完了之后才会调用`main函数`执行`main函数`相关的这些东西，所以你会看到我们这个地方在这个栈底，其实画了一些`……`，就是说在`main函数`之前，其实还需要把某一些我们不知道的信息压入占顶
* **IDE调试变量**
  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211107576.png" alt="image-20230421110713302" style="zoom: 50%;" />
  * 在`n=x+2;`这下了一个断点，用调试模式运行这个程序的时候，它就会被卡住，这个时候你可以在你的`IDE`里边看到此时你的程序,它的函数调用栈是什么样的一个情况。我这用的`IDE`是`CLion`你用其他的`IDE VS`之类的都可以。肯定都有这种调试变量的功能
  * 可以看到当代码运行到`n=x+2;`这一句的时候，函数调用栈栈顶其实是`func2函数`。也就是这个函数相关的一些信息，这里边有参数`x`的值，也有局部变量`m`和`n`，可以用鼠标点一下这个栈里边的其他这些元素，比如说`func1函数`。你会看到这个`func1函数`里边，它包含`a`和`b`这两个参数`a`和`b`，然后还有`x`这个局部变量
  * 那`main函数`也是一样的。那除了`main函数`之外，其实在这个栈底，它还压入了其他的一些信息，只不过这些信息并不需要我们普通程序员关心。
  * 总之，用IDE来debug的时候，其实是可以通过这样的方式来观察你的函数调用栈里边保存了哪些东西。当然了，它这儿并没有显示返回地址。



## 栈在递归中的应用

* **适合用“递归”算法解决：**可以把原始问题转换为**属性相同**，但**规模较小**的问题

* **实现递归算法两个主要的东西**

  * 递归表达式
  * 边界条件（递归出口）

* **例1：正整数的阶乘——n！**

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211115137.png" alt="image-20230421111519066" style="zoom: 60%;" />

  * 计算一个正整数的阶乘`n!`，可以把它转换成`n*(n- 1)!`，问题规模从`n`变成了`n- 1`，它的规模变小了，同时属性是相同的，都是要计算阶乘

* **例2：求斐波那契数列**

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211127794.png" alt="image-20230421112734689" style="zoom:60%;" />
  * 可以把问题规模`n`拆分成计算问题规模`n- 1`和`n-2`这样的两个部分。
  * 也是一样的有相同的特性

* **递归算法和栈的联系**

  * **例1：递归算法求阶乘**

  * ~~~C++
    //计算正整数n！
    int factorial(int n){
    	if(n==0 || n==1)
    		return 1;
    	else
    		return n*factorial(n-1);
    }
    
    int main(){
    	//…其他代码
    	int x=factorial(10);
    	printf("奥利给!");
    }
    ~~~

    * 计算阶乘的递归函数，传入了一个参数`10`也就是要计算`10！`
    * 阶乘函数又会递归调用它自身，只不过问题规模会逐渐的收敛，逐渐的缩小。
    * 既然涉及到函数调用，只要函数调用，其实背后就
      需要栈的支持
    * 递归调用时，函数调用栈可称为递归工作栈.
    * 但是本质上和函数调用栈是同一个东西，也就是在这个栈里边，你需要压入一些我们不知道是什么的栈底信息，然后和`main函数`相关的局部变量这些信息
      * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211325483.png" alt="image-20230421132549416" style="zoom:50%;" />
    * 接下来`main函数`要调用`factorial函数`，然后传入的实参值是`10`，那在`factorial(10)`调用结束之后，它应该接着执行192行这句代码`int x=factorial(10);`，就是需要把这个函数执行的结果把它赋给`x`这个变量
      * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211347910.png" alt="image-20230421134704753" style="zoom: 50%;" />
    * 那此时这个函数的实参`n=10`，那由于`n`不等于0，也不等于1，所以它会执行`return n*factorial(n-1);`这段代码，这段代码又会递归地调用它自身`factorial(n-1)`只不过n的值会减1，也就是变成9，那么在下一层调用结束之后，它又回来接着执行187行`return n*factorial(n-1);`这句代码，因为需要把`factorial(n-1)函数`的返回值和n进行一个相乘，然后再`return`
      * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211357567.png" alt="image-20230421135703393" style="zoom:50%;" />
    * 那接下来这个`int factorial(int n)`的实参是9再往后原理是类似的，就不再展开分析.
      * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211403883.png" alt="image-20230421140338753" style="zoom: 50%;" />
    * 问题规模会逐渐收敛，直到n的值为1，也就是这个

    实参传入的是1的时候，由于满足`n==1`这个条件，所以就可以直接`return 1`这也就意味着它的上一层函数的`factorial(n-1)`这个运算得到的值就是被返回的

    * 那最深层的这一次调用返回之后，它可以把与它相关的这些信息给弹出栈，然后回到上一层继续执行187行`return n*factorial(n-1);`这句代码，那经过检查，你会发现这个栈里边记录了这一层的参数n，n的值是2，而刚才的`return`返回值是1.所以这层函数的这个`return`值就会`return 2*1`

      * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211410034.png" alt="image-20230421141050916" style="zoom: 50%;" />

      * 那往后原理都是类似的，就可以逐层的返回，直到第一层的调用，第一层的调用里边n的值是10，通过之前的一系列的计算，这儿的`factorial(n-1)`这次调用，返回值应该是9的阶乘.那最后的这一层函数就可以计算它的n也就是10乘以9×8×7……×1这串东西，然后把这个值给`return`返回给`main函数`，然后接着执行`main函数`的192行代码`int x=factorial(10);`这行代码会10的阶乘的值赋给变量`x`
        * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211417530.png" alt="image-20230421141745408" style="zoom: 50%;" />
        * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211421064.png" alt="image-20230421142141929" style="zoom:50%;" />

    * 所以在递归调用当中，每当进入一层更深的递归的时候，就会把这层递归调用所需要的信息压到栈顶，然后每执行完一层递归调用，就会从栈顶弹出相关的信息.

    * 刚才我们这儿`int x=factorial(10)`传入的参数是10，如果我们传入的参数大点，比如说传入个十万。那么就意味着这个栈里边会被压入十万条信息，所以用递归算法有一个**缺点**，就是如果我们的递归层数太多的话，那么有可能会导致栈溢出。因为我们的内存资源是有限的，包括系统给我们开辟的函数调用栈，它肯定也是有一个存储的上限的。

    * 通过这个例子，就应该更能够理解在绪论里谈到的递归带来的空间复杂度升高这个问题。递归层数越多，那相应的空间复杂度也会越高，同样的大家也可以在自己的IDE上下一个断点，然后观察一下执行到某一句代码的时候，函数调用栈里边包含了哪些信息.

    * 由于递归算法背后其实就是用一个栈来实现的，因此如果需要把递归算法改造成非递归的实现方式的话，完全可以自己定义一个栈。然后用类似的思想来实现它

  

  * **例2：递归算法求斐波那契数列**

    * ~~~C++
      int Fib(int n){
      	if(n==0)
      		return 0;
      	else if(n==1)
      		return 1;
      	else
      		return Fib(n-1)+Fib(n-2);
      }
      
      int main(){
      	//…其他代码
      	int x=Fib(4);
      	printf("奥利给！");
      }
      ~~~

    * 我们`main函数`里边传入的参数是4，由于`n==0`和`n==1`这两个条件不满足，所以它会再调用`Fib(n-1)`和`Fib(n-2)`。

    * 那首先被调用的是`Fib(3)`，那这就会进入更深一层的递归，此时还没到达这个递归的边界条件，所以又会继续往更深层调用，会调用`Fib(2)`和`Fib(1)`，那首先被调用的是`Fib(2)`，那执行`Fib(2)`的时候又会递归的调用`Fib(1)`和`Fib(0)`

    * 首先，被调用的是`Fib(1)`，那当这个`n==1`的时候，由于满足`n==1`这个边界条件，所以可以`return 1`

      * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211451511.png" alt="image-20230421145140418" style="zoom: 50%;" />

    * 然后就可以弹出这个栈顶元素

    * 那接下来在`Fib(2)`这一层还需要调用`Fib(0)`那同样的到达边界条件之后就可以返回.到此为止，`Fib(2)`相关的这两个` Fib(n-1)`和`Fib(n-2)`调用都已经有返回值了，所以`Fib(2)`也可以接着往上一层返回。

    * 其实刚才的过程就是4调用3，3调用2，然后2先调用1，1返回之后2又调用0，0再返回之后2返回3，3调用1，然后1再返回之后3再返回4，

      就用这样的方式逐层的把这个递归调用给完成。

      * ![image-20230421151606470](https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202304211516567.png)

    * 用这样的方式就计算出了`Fib(4)`的值，会看到在这个计算的过程当中`Fib(2)`的值其实是被计算了两次。然后`Fib(1)`和`Fib(2)`同样的也是被重复了多次，所以用递归实现的算法，它也有可能在某些时候会包含很多次的重复运算，因此这也是递归算法不太高效的其中一个原因

      