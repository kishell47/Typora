# 操作系统的运行机制



## 知识总览

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305070936542.png" alt="image-20230507093621365" style="zoom:50%;" />

* 操作系统的运行机制：操作系统在计算机上是怎么运行的
* 学习两种类型的指令，两种处理器状态和两种程序，它们都是一一对应的



## 预备知识：程序是如何运行的?

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305070954985.png" alt="image-20230507095440853" style="zoom: 60%;" />

* 程序在计算机硬件上底层是怎么运行的，程序运行的基本原理是什么
* 其实像我们平时用C语言代码写的那些程序都会经过编译器进行编译的工作，把这个C语言代码翻译成计算机能够听得懂的二进制代码也就是机器指令，像我们平时用C语言这种高级语言写的一条代码，经过编译，翻译之后可能会对应很多很多条机器指令。
* 比如说我们定义了一个int型的变量x=1，并且对x进行了加加，也就是加一的操作，那么这样两行短短的代码可能经过编译之后形成的机器指令就会对应这么多条，当然这个地方我也是随便胡乱写的，因为都是二进制数，反正我们都看不懂。 
* 但是虽然我们看不懂这些二进制数，但是对于CPU对于计算机来说，这样的二进制代码才是他能够看得懂的一种语言。 所以其实我们这一段程序运行的过程就是CPU把这些机器指令一条一条的执行的过程。
  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305070946198.png" alt="image-20230507094619071" style="zoom: 50%;" />
* 而这些机器指令在背后实现的其实就是我们用代码表示的这一小段的逻辑，只不过这种二进制的机器指令是CPU能看懂，但是我们看不懂的。 所以这个地方所提到的机器指令，其实就是让处理器也就是CPU能够识别并且执行的最基本的一个命令。 比如说进行一个加法操作，或者进行一个赋值的操作等等
* 这个地方的指令的概念比较容易和另一个概念混淆。 很多同学会习惯把Linux、Windows等等这种小黑框里输入的这种ls、cd等等这样的命令称作为指令，但是其实这个小黑框里所用的这个命令，其实是之前提到过的交互式命令接口。它和我们这个小节所讲的指令是不一样的，我们这指的指令是指二进制的机器指令，所以大家需要对接下来所提到的指令进行区分。 
* 总之，我们平时用高级语言编写的这种程序，最后执行的时候肯定是需要变成CPU能够读得懂的用二进制的机器指令表现的这种形式。



## 内核程序 v.s. 应用程序

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305070955228.png" alt="image-20230507095553076" style="zoom: 67%;" />

* 在操作系统这门课当中，需要注意区分两种类型的程序，一种叫内核程序，一种叫应用程序。
* **应用程序**就是跑在操作系统之上的，我们平时很熟悉，很喜欢用的那些程序比如说QQ、微信等等，像普通程序员写的程序，其实就是应用程序，是跑在操作系统之上的
* 但是还有一些人，比如说像微软苹果会有一帮人是负责开发操作系统的这帮人写的那些程序就是所谓的操作系统的内核程序，这帮人编写了很多很多的内核程序，这些内核程序最终组成了所谓的操作系统的内核，英文叫`kernel`，这个内核就是操作系统最核心的部分，也是最接近硬件的部分。 
* 之前提到过操作系统最重要的一个角色，是它要作为系统资源的管理者，而操作系统对系统资源的管理工作，其实就是在内核部分来实现的，我们甚至可以说操作系统，只要有内核就可以了。 比如说容器技术Docker，在Docker容器里只需要有Linux的内核，其实就可以实现Linux的所有的功能了。
* 用户平时使用的操作系统其实它包含的不只是内核的功能，比如说图形化的用户界面，就不是放在内核当中实现的。 即使没有图形化的用户界面，我们依然可以用命令行，也就是之前所提到的小黑框的那种方式来使用操作系统。 所以操作系统的内核当中所包含的只是操作系统当中最重要，最核心，最必不可少的那些功能。

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305071008502.png" alt="image-20230507100838373" style="zoom: 67%;" />

* 既然操作系统内核是系统资源的管理者，作为管理者，这样的一个角色，有的时候就有可能会让CPU执行一些比较特殊的指令。比如说内存清零的指令，这种指令会对其他程序的运行造成很严重的影响，像这样的特权指令运行之后是有可能影响到其他程序的正常运行的。 所以这样的特权指令就应该只允许系统的管理者，也就是操作系统内核来使用。 也就是说，假如这一段程序是内核程序的话，那这些指令当中可以出现特权指令。而假如说这段程序是普通的应用程序的话，那么这其中就不应该包含特权指令，而只能使用非特权的指令。比如说让CPU做加减乘除运算的一系列的指令就是非特权的指令。
* CPU在设计和生产的时候就划分了哪些指令是属于特权指令，哪些指令是属于非特权指令。 所以CPU在拿到一条指令的时候，其实它是可以区分出它到底是特权指令还是非特权指令的？
* 那么问题就出现了。CPU在执行程序的时候，它只会负责把这些指令一条一条的执行。虽然它能够分辨出哪些指令是特权指令，哪些指令是非特权指令。 但是它又怎么分辨出此时正在执行的这个指令到底是一个应用程序的指令，还是一个内核程序的指令呢？



## 内核态v.s.用户态

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305071018012.png" alt="image-20230507101801864" style="zoom: 67%;" />

* 接下来要研究的就是为了让CPU能够区分此时正在运行的这些指令是属于应用程序还是内核程序
* CPU会被划分成两种状态，一种叫内核态，一种叫用户态，当CPU处于内核态的时候，说明此时CPU正在运行的是内核程序。在这个时候是可以执行特权指令的，而如果CPU处于用户态，那么说明此时CPU正在运行的是应用程序，此时CPU就只能执行非特权指令。
* 怎么区分CPU到底处于哪种状态呢，在CPU当中会有一个寄存器，也就是一个存数据的地方,叫做程序状态寄存器，英文缩写叫`PSW`。这个寄存器当中会有一个二进制位，这个二进制位为1的时候表示CPU此时是处于内核态的，而二进制为0的时候表示CPU此时处于用户态。 当然，也有一些CPU有可能是0表示内核态，1表示用户态，但是这个无关紧要，我们只需要知道用二进制的方式，其实就可以实现对CPU状态的一个标记。
* 用户态和内核态它们还有各自的别名用户态又可以叫目态，内核态又可以叫做管态。这两个术语大家也需要注意一下



## 内核态、用户态的切换

* 接下来要探讨的问题是CPU要怎么实现这两种状态之间的切换

* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305071026740.png" alt="image-20230507102646575" style="zoom: 80%;" />

* 直接用一个例子让大家看一下CPU状态切换的过程。

* <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305071327464.png" alt="image-20230507132707304" style="zoom: 67%;" />

* 首先，当开机的时候，需要加载操作系统，然后这个操作系统就需要进行一些初始化的工作。 系统初始化的工作，其实就是由操作系统当中的某一些内核程序来完成的，所以在开机的过程当中需要执行内核程序，因此在这个时候CPU肯定是需要处于内核态。 它需要来执行系统初始化相关的一系列的内核程序的指令。

* 当开机完成之后，用户就可以启动某一些应用程序，这个应用程序要正常运行的话，肯定需要让CPU执行它的这一系列的指令。 但是刚才不是说CPU此时正在执行的是内核程序吗，如果说要让它运行这个应用程序的话，怎么实现这个事情呢？

* 此时如果操作系统的内核，想让应用程序开始运行的话，那么这个内核程序就需要执行一条特权指令。 这个特权指令会把`PSW`的标志位从内核态转变为用户态，这样的话就完成了CPU状态的切换。

* 接下来，操作系统内核就会让出CPU的使用权，让这个应用程序上CPU运行。而此时，CPU已经被切换为用户态了，所以接下来应用程序会在用户态下运行。 CPU会执行这个应用程序的一条一条的指令

* 此时一个小故事发生了，假如说此时有一个猥琐的黑客。 在这个应用程序当中，植入了一条特权指令的话，会发生什么事呢？

* 首先，CPU在读入这条指令的时候，其实就已经能够判断这条指令是一条特权指令了。但是CPU又检查了自己的`PSW`寄存器，发现自己此时是处于用户态的。 这样的话，CPU就能够知道此时正在运行的其实是应用程序，而不是内核程序，而一个应用程序竟然想要用一个特权指令，这个事情坚决不能让他干。

* 所以这样的一个非法事件会引起一个中断信号，当CPU检测到这个中断信号之后，它就会立即强行变态强行变成核心态。并且CPU会拒绝执行这一条特权指令。

* 接下来，CPU会暂停执行这个应用程序后面的这一系列的指令代码转而会执行一个处理中断信号的内核程序。

* 接下来CPU就在内核态下来执行这个内核程序相应的这一系列的指令。 所以其实刚才发生了这个中断信号之后，让操作系统内核又重新夺回了CPU的控制权。接下来，操作系统的内核程序会对这个中断进行相应的处理，等处理完了之后，它才会把CPU的使用权再重新还给应用程序。

* 所以从这个故事当中，就可以很形象地看到CPU从内核态切换回用户态是执行了一条修改`PSW`标志位的一个特权指令来完成的。 执行了这个特权指令之后，就意味着操作系统内核要主动地让出CPU的使用权了。

* 当CPU切换为用户态之后，就可以在CPU上运行用户程序，而CPU的状态从用户态又切换回内核态，是由中断引发的，由CPU硬件自动地完成这个变态的过程，并且CPU变回内核态之后，它会停止运行当前正在运行的应用程序转而运行一个内核程序，所以说其实触发了一个中断信号，就意味着操作系统会强行重新夺回CPU的使用权。 除了非法使用特权指令之外，还会有别的很多的事件也会触发这个中断信号。一个共性是但凡我需要操作系统来介入开展管理工作的时候就会触发一个中断信号。具体有哪些中断会在下一个小节当中进行更进一步的学习。

  

## 知识回顾与重点考点

<img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202305071345560.png" alt="image-20230507134548362" style="zoom: 80%;" />

* 这个小节当中用一个故事来捋清了操作系统的运行机制，CPU运行程序的过程其实就是在执行一条一条机器指令的过程。
* 而系统中存在两种程序，一种是内核程序，一种是应用程序
* **内核程序**是整个系统的管理者，所以它需要使用到一些特权指令，并且特权指令只有内核程序可以使用，当CPU的状态是内核态的时候，说明此时正在跑的这些指令是属于内核程序的。 
* 当CPU处于用户态的时候，说明此时正在跑的是应用程序的指令。
* 由一系列的内核程序就组成了操作系统的内核，它是整个系统最核心，最接近硬件的部分。
* 还强调了CPU是如何变态的，内核态到用户态的转变，是用一条特权指令实现的，而用户态到內核态的转变是由中断引起的，然后由CPU硬件自动完成。
* 这个小节的内容都是十分重要的，很容易在选择题当中进行考察。这个小节虽然说很重要，但是它一般来说也就考察一个选择题。 所以分值也不会占的特别高，大家可以结合我们的教材和课后习题来进行更进一步的巩固。 